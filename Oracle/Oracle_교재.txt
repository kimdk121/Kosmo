■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<1> 데이터베이스 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	[검색]이 용이하도록 일정한 기준에 맞추어 자료를 분류하여 정리해 놓은 [자료의 집합]을 말한다.

	데이터베이스 조건
		실시간 접근성, 지속적인 변화(=최신의 정보가 정확하게 저장), 동시 공유 등

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<2> RDBMS (Relational Database Management System, 관계형 데이터베이스 관리 시스템)란?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	
	● 데이터가 [컬럼(column=열)]과 [로우(Row=행)]로 이루어진 [테이블]에 저장되며, [테이블]들 사이에 관계를 설정하여
		관리하는 SW또는 시스템을 말한다.

	● RDBMS 제품의 종류
		Oracle 사의 Oracle => 대기업용
		MS사의 MS-SQL 	=> 대기업용
		Sun Microsystems 	=> 중소기업용
		Sybase
		DB2 등

	● 고객의 정보를 저장하는 테이블 customer 가 있다면 아래와 같은 구조로 데이터를 저장하여 관리한다.
	---------------------------------------------------------

			customer				=> 테이블명
	----------------------------------------------------------
	고객번호		고객명	주소	전화번호		=>column명
	----------------------------------------------------------
	1		저팔계	서울	02-1234-1234	=>row(행)
	----------------------------------------------------------
	2		사오정	부산	02-2345-2345	=>row(행)
	----------------------------------------------------------
	3		손오공	제주	02-3456-3456	=>row(행)
	----------------------------------------------------------
	↓		↓	↓	↓
	column		column	column	column
	(열)		(열)	(열)	(열)


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<3> SQL(Structured Query Language)이란 뭡니까?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	● RDBMS에 접근해서 데이터의 [입력], [수정], [삭제], [검색] 하는 등의 기능을 가진 RDBMS 관리 언어 이다.
	<참고> DB, 즉 오라클을 배운다라는 말은 SQL 언어를 배우는 것과 동일하다.

	● 특징
		▶ [절차적 언어]가 아닌 [구조적 언어]이다.
			<참고> 절차적(procedural) 언어 (입)
				▷모든 처리 과정을 일일이 기술하고 기술된 순서대로 로직이 처리되는 언어. ( C, Java 등)
			<참고> 구조적(structured) 언어 (입)
				▷처리 과정을 일일이 기술할 필요 없이 일정한 틀이나 패턴이 있어 맞게 조건들만 나열하면
			  	로직이 처리되는 언어.

	● SQL 종류 ( 기.입 )
		------------------------------------------------------
		DDL (Data Definition Language = 데이터 정의 언어)
		------------------------------------------------------
			▶객체를 생성, 수정, 삭제 등의 작업을 한다.
			----------------------------------
			CREATE => 객체 생성
			ALTER => 객체 수정 <조심>update가 아니다. 시험문제에 자주 등장
			DROP => 객체 삭제
			기타 등등
			----------------------------------
			<주의>오라클에서 객체란 이름을 가지고 저장되는 놈들을 객체라 부른다. 자바의 객체와 다르다.
			<참고>오라클에서 객체는 [테이블], [뷰], [트리거], [인덱스], [프로시저], [시퀀스] 등을 말한다.

		-----------------------------------------------------------
		DML (Data Manipulation Language = 데이터 처리 언어)
		-----------------------------------------------------------
			▶ 테이블 안의 데이터를 입력, 수정, 삭제, 검색 등의 작업을 한다.
			---------------------------------------
			INSERT  => 행 단위의 데이터 입력
			UPDATE => 셀 단위의 데이터 수정/삭제
			DELETE  => 행 단위의 데이터 삭제
			SELECT  => n행 m열의 데이터 검색
			기타 등등
			---------------------------------------
			<문> 셀에 들어있는 데이터를 제거하는 SQL 구문은? UPDATE 학원 프로젝트에 주도적으로 참여했는지 알수 있는 질문.
			<문> 행을 제거하는 SQL 구문은? DELETE
		----------------------------------------------------------
		DCL (Data Control Language = 데이터 제어 언어)
		----------------------------------------------------------
			COMMIT   => 트랜잭션 작업 단위의 데이터 입력, 수정, 삭제 작업을 모두 인정
			ROLLBACK => 트랜잭션 작업 단위의 데이터 입력, 수정, 삭제 작업을 모두 취소
			GRANT     => 접근제어, 작업권한허용
			REVOKE    => 권한제거	

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<4> 트랜잭션(Transaction) 이란 뭡니까?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	● 모두 취소되거나 모두 완료되는 2가지 결과로만 진행되는 작업 단위를 말한다.
	
	● 트랜잭션은 주로 입력 또는 수정 또는 삭제 SQL 구문 실행 시 설정한다.
	
	● 트랜잭션이 걸린 작업은 가상 작업이 되고 rollback 을 실행하면 모두 취소되고 commit을 실행하면
		가상작업이 모두 실제 작업으로 인정된다.
	
	● <주의> 트랜잭션은 의도를 가지고 설정하는 것이다.

	● <주의> 트랜잭션이 없는 작업은 N가지 이상의 다양한 결과로 진행 될 수 있다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<5> 오라클에서 [계정] 이란 뭡니까?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	● 오라클에 접속하는 사용자를 말한다.

	● 사용자 마다 권한을 다르게 줄 수 있다.
	
	● 오라클은 다수의 클라이언트에게 동시에 정보를 제공하는 서버이므로 서버의 특징인 계정과 암호를 가지고 있다.

	------------------------------------------------
	<참고> 서버(SERVER) ?
	------------------------------------------------
		다수의 클라이언트에게 동시에 정보를 제공하는 H/W 나 S/W를 말한다.
	
	● 오라클 계정의 종류
		-----------------------------------------------------------------------------------------
		SYS	-> 오라클 설치 시 기본적으로 만들어지는 계정. 모든 것을 할 수 있다.
		-----------------------------------------------------------------------------------------
		SYSTEM  -> 오라클 설치 시 기본적으로 만들어지는 계정. 모든 것을 할 수 있다.
				단 [데이터베이스] 생성 권한이 없다.
		-----------------------------------------------------------------------------------------
		SCOTT   -> 오라클 설치 시 기본적으로 만들어지는 계정. 권한이 거의 없다.
		-----------------------------------------------------------------------------------------
		생성 계정 -> 계정 생성 권한을 가진 계정이 만드는 계정이므로 계정별 권한이 설정된다.
				주로 SYS, SYSTEM 계정 또는 SYS, SYSTEM 계정과 동일한 권한을 가진 계정이 만든다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<6> 데이터베이스 차원에서 스키마 (Schema) 란 뭡니까?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	● [데이터베이스의 구조]에 대한 정의와 제약조건 등을 기술한 [명세서]를 말한다.

	● [계정]이 생성한 모든 [객체]들을 의미 한다. (오라클 객체 => 테이블, 뷰, 인덱스, 프로시저, 트리거 등)
		객체들이 DB구조에 대한 정의와 이에 대한 제약조건 등을 기술한 [명세서]이기 때문이다.
	
	● [kim] 계정이 객체(테이블, 인덱스, 뷰 등) 들을 생성했다면 이 객체들 모두를 가리켜 [kim 스키마]라고 한다.
	
	● 생성되는 객체는 [계정명. 객체명] 형식으로 저장된다.

		abc => employee 테이블 생성.	abc.employee 형태로 저장됨
		kim => employee 테이블 생성.	kim.employee 형태로 저장됨
		kim => employee 테이블 생성. 	kim.employee 형태로 저장안됨  이미 존재하므로.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<7> 데이터베이스 차원에서 테이블 (table) 란 뭡니까?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	● RDBMS 에서 데이터가 실질적으로 저장되는 [논리적 장소 (=S/W 적인 장소)] 를 말한다.

	● [컬럼(column =열)]과 [로우(Row열=행=record)]로 구성되어 있다.

	● 테이블은 이름가지고 저장되는 객체의 한 종류이다.
	
	● 개발자 입장에서 제일 손이 많이 가는 객체이다.

	● 테이블에 데이터 입력(INSERT) 수정(UPDATE) 삭제(DELETE) 검색(SELECT)


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<8> 테이블 (table)을 생성하는 SQL 구문의 형식은 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	------------------------------------------------
	CREATE TABLE 테이블명(
		컬럼명1	자료형	제약조건
		,컬럼명2	자료형	제약조건
		,~
		, 컬럼명n	자료형	제약조건
	);
	------------------------------------------------

	---------------------------------------------------------------
	자료형(Data type) => 테이블의 컬럼에 입력될 데이터의 유형을 말한다. 문자형, 숫자형, 날짜형 등이 있다.
	---------------------------------------------------------------
	제약조건 => 입력되는 데이터의 입력 가능 조건을 말한다. 제약조건에 위배되는 데이터는 삽입될 수 없다.
			제약조건이 생략되면 데이터가 입력되지 않을 경우 null 이 저장된다.
	---------------------------------------------------------------
	<주의> 테이블명, 컬럼명 제작 규칙
		▷ 영문자, 1~9, $, #, _ 로 구성되고 반드시 영문자로 시작해야 한다.
		▷ 30자를 초과할 수 없다. SQL 예약어는 사용할 수 없다.
		▷ 하나의 계정이 만든 테이블명은 유일해야 하고 하나의 테이블 안에서 컬럼명은 유일해야한다.
		▷ 테이블명, 컬럼명, 제약조건명을 " 로 감싸거나 " 없이 그냥 써도된다.
		▷ 테이블명, 컬럼명 은 가독성 있게 주는 것이 제일 중요하다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<9> 오라클에서 자료형의 종류는 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	--------------------------------------
	CHAR(s) //일정한 글자 크기
	--------------------------------------
		
		▶ 고정길이 문자열 저장. s는 byte 수를 의미.
		▶ 설정 크기보다 입력 문자 크기가 작으면 공백으로 남는다.
					       크면 행 자체가 입력되지 않는다.
		▶ <예> CHAR(4) => 문자 4byte 까지 입력가능. 즉 영문 4개까지, 한글 2개까지 가능
				<참고> 영문 1자는 1byte 차지, 한글 1자는 2byte 차지.
		▶ 최대크기는 2000byte 이다.
		▶ CHAR는 CHAR(1)과 동일. (성별이라던가..)
		
		// 단점. 모자라면 공백, 고객 요구사항 반영힘듬..

	--------------------------------------
	VARCHAR2(s) //가변형 글자 크기
	--------------------------------------
		
		▶ 가변길이 문자열 저장. s는 byte 수를 의미.
		▶ 설정 크기보다 입력 문자 크기가 작으면 크기가 자동으로 줄어든다. (DB 서버 부담은 증가)
					       크면 행 자체가 입력되지 않는다.
		▶ <예> VARCHAR2(4) => 문자 4byte 까지 입력 가능. 즉 영문 4개까지, 한글 2개까지 가능.
		▶ 보통 테이블을 설계할 때는 CHAR 타입보다는 VARCHAR2 타입을 많이 사용한다.
			임의의 컬럼의 입력값 길이를 정확하게 예측하더라도 나중에 변경될 가능성이 많기 때문이다.
		▶ 최대 크기는 4000byte 이다.
		▶ (괄호) 없이 VARCHAR2만 쓸순없다.

		// 단점. 서버에 부하가 갈 수 있다.
		
	--------------------------------------
	NUMBER(p,s)
	--------------------------------------
		
		▶ 정수형 또는 실수형 숫자 저장.
		▶ p (precision) => 전체 자릿수(1~38). s (scale) => 소수점이하 자릿수(-84~127)
		▶ s 생략 시 디폴트 0 설정.
		▶ NUMBER 는 즉 p(precision), s(scale) 모두 생략 시 정수, 소수점이하 자릿수 합쳐 40자리 까지 저장.
		▶ 소수점 자리수가 넘치면 반올림하고 정수 자리수가 모자라면 오류가 난다. 즉 행 입력이 안된다.
		
		===================================================
		▶ <예> NUMBER(6, 2) 라고 지정한 컬럼에 1234.56 을 저장하면?
			6 = 전체 , 2= 소수점 2자리 (정수 4자리, 소수점 2자리) 1234.56 그대로 입력됨.
		▶ <예> NUMBER(6, 2) 라고 지정한 컬럼에 1234.567 을 저장하면?
			정수가 짤리면 입력불가 소수점은 반올림 되면서 짤림	1234.57 저장됨.
		▶ <예> NUMBER(3) 라고 지정한 컬럼에 123 저장하면 ?	123 그대로 저장됨
			소숫점은 없어도 되므로 지정을 안해줘도 된다.
		▶ <예> NUMBER(3) 라고 지정한 컬럼에 123.4 저장하면 ?
			소수점 1자리에서 반올림해서 저장.	123 그대로 저장
		▶ <예> NUMBER(3) 라고 지정한 컬럼에 1234 저장하면 ?
			정수가 짤리면 입력불가	저장오류
		===================================================		
		
	--------------------------------------
	DATE
	--------------------------------------

		▶ [년, 월, 일, 시, 분, 초] 저장.
		▶ 저장 범위는 BC 4712년 1월 1일~ 9999년 12월 31일.
		▶ <참고> 보통 날짜형 데이터는 SQL 문장에서 [TO_CHAR], [TO_DATE] 변환함수와 같이 사용된다.
				// [TO_DATE] 날짜로 계산할 때 사용, [TO_CHAR] 포장해서 출력할 때 사용
		▶ 2021년 6월 11일 부터 2021년 12월 25일 남은 일수 검색하는 SQL 구문 작성
			====================================================
			SELECT TO_DATE('2021225', 'YYYYMMDD')-TO_DATE('20210611', 'YYYYMMDD') FROM DUAL
			====================================================
		▶ 오늘 날짜를 연 - 월 - 일 형식으로 출력
			====================================================
			SELECT TO_CHAR (SYSDATE, 'YYYY-MM-DD') FROM DUAL
			====================================================
		▶ <참고> 변환함수는 [TO_CHAR], [TO_DATE], [TO_NUMBER] 와 같이 사용된다.
		
	--------------------------------------
	기타
	--------------------------------------		
	
		<참고>기타 문자형에는 CLOB, LONG, NCHAR(s), NVARCHAR2(s), NCLOB 등이 있다.
		<참고>기타 숫자형에는 BINARY_FLOAT, BINARY_DOUBLE 도 있다.
		<참고>기타 날짜형에는 TIMESTAMP(f), TIMESTAMP(f) WITH TIME ZONE, TIMESTAMP(f) LOCAL WITH TIME ZONE 도 있다.

		
	NUMBER	VARCHAR2	VARCHAR2 // 주민번호는 계산하는 과정이없으므로 
	------------------------------------------	문자형인 VARCHAR2로 줌.
	고객번호	고객명	주소	주민번호
	1	사오정	서울	9012251111111

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<10> 오라클에서 제약조건의 종류는 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	--------------------------------------
	not null
	--------------------------------------
		▶ 반드시 데이터가 입력되어야 한다. 필수 입력 데이터
	--------------------------------------
	unique
	--------------------------------------
		▶ 중복되는 데이터는 입력 불가능하다. // 무료인 데이터
		▶ <예> 주민번호, 전화번호, 직원번호 등등...
		▶ 일반적으로 또는 관용적으로 unique를 가진 컬럼은 not null도 같이 들어간다. (대체로)
	--------------------------------------
	default
	--------------------------------------
		▶ 데이터를 입력하지 않으면 디폴트로 설정한 값이 입력된다.
		▶ <예> 회원가입할 때 가입날짜를 입력하지 않아도 그 당일날짜가 저장되는 경우
	--------------------------------------
	check
	--------------------------------------
		▶ 지정한 데이터만 입력 가능하다.
		▶ <예> 성별 입력 시 남 또는 여 만 입력되는 경우
	--------------------------------------
	primary key (PK)
	--------------------------------------
		▶ not null, unique 의 제약조건 성질을 가진다. 즉 행과 행을 구분할 수 있는 유일한 데이터가 입력된다. 
		▶ 하나의 테이블에 하나의 primary key만 설정할 수 있다. 즉 테이블당 0~1개만 줄 수 있다.
		▶ 차후에 foreign key에 의해 참조 당하는 키다.
		▶ [기본키], [주키] 라고도 한다.
	--------------------------------------
	foreign key (FK)
	--------------------------------------
		▶ primary key에 존재하는 데이터만 삽입될 수 있다. (=primary key를 참조하는 키다.)
		▶ <주의> 예외적으로 null 값은 입력 가능하다. 즉 데이터가 입력되지 않을 수 도 있다.
		▶ 하나의 테이블에 0 개 이상의 foreign key를 설정할 수 있다.
		▶ table과 table 간의 관계를 설정하는 키다.
		▶ [참조키], [외래키], [관계키], [종속키] 라고도 한다.
			// PK있다고 FK가 다있진않지만 FK가 있다면 PK는 다 있다.
		
			
				employee
	=============================================
	e_no	e_name	    dep_name	salary	jikup
	=============================================
	1	사오정	    관리부	5000	대리
	2	저팔계	    영업부	6000	과장
	3	손오공	    자재부	7000	부장
	number	varchar2	    varchar2	number	varchar2	
	not null	not null	    		default
	unique
	
	
				dept 
	===============================================
	dep_no(PK)	dep_name   
	===============================================
	10		관리부
	20		자재부
	30		홍보부
	40		사업부


				employee 
	===============================================
	e_no(PK)	e_name	dep_no(FK) salary	jikup	mgr_e_no(FK) 
	===============================================
	1	사오정	10	   5000	대리	3
	2	저팔계	20	   6000	과장	3
	3	손오공	30	   7000	부장	null
	4	사오정	40	   5000	대리	2


            			customer 
	===============================================
	c_no(PK)	c_name	phone	e_no(FK)
	===============================================
	1	사오순	~	2
	2	저팔순	~	4
	3	손오순	~	1
	4	사오순	~	2

	
	---------------------------------------------------
	1. FK 가 있으면 반드시 PK 가 있다. 	( o )
	---------------------------------------------------
	2. unique 가 걸린 컬럼에는 반드시 not null 이 걸린다..	( x )
	---------------------------------------------------
	3. 자료형도 데이터를 걸러내는데 사용된다.	( o )
	---------------------------------------------------
	4. not null 이 걸린 컬럼에는 반드시  unique 가 걸린다..	( x )
	---------------------------------------------------
	5. 셀을 삭제하는 명령어는 update 이다.	( o )
	---------------------------------------------------
	6. 행 삭제는 alter 구문이다.		( x )
	---------------------------------------------------
	7. 행 수정은 update 구문이다.	( x )
	---------------------------------------------------
	8. create 로 만든 테이블은 rollback 으로 없앨수 있다.	( x )
	---------------------------------------------------
	9. select 도 트랜잭션을 걸수 있다.	( o )
	---------------------------------------------------
	10. default 가 걸리면 대부분 not null 이다.	( o )
	---------------------------------------------------
	11. 제약조건을 위배하면 셀에만 데이터가 입력이 안된다.	( x )
	---------------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<11> 시퀀스(sequence) 가 뭡니까 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	● [고유 일련 번호]를 생성해서 제공하는 객체이다. 일종의 [일련 번호 생성기] 이다.
	● 주로 하나의 테이블에서 PRIMARY KEY 로 지정된 컬럼명에 입력될 [일련 번호] 값을 생성한다.
	● <비유> 은행에서 번호표 뽑는 기계아 동일한 기능을 가진다.

	--------------------------
	● 시퀀스 생성 SQL 구문
	--------------------------
		----------------------------------------------------
		CREATE SEQUENCE 시퀀스명
			START WITH 시작값
			INCREMENT BY 증가값
			MINVALUE 최소값
			MAXVALUE 최대값;
		----------------------------------------------------
		CREATE SEQUENCE SQ_EMP
			START WITH 1
			INCREMENT BY 1
			MINVALUE 1
			MAXVALUE 9999;
		----------------------------------------------------
		CREATE SEQUENCE SQ_EMP
			START WITH 1
			INCREMENT BY -1
			MINVALUE 1
			MAXVALUE 9999;
		----------------------------------------------------
	--------------------------
	● 증가된 새 일련번호 얻는 SQL 구문
	--------------------------
		시퀀스명.nextval
	--------------------------
	● 마지막으로 이미 뽑혔던 일련번호 얻는 SQL 구문
	--------------------------
		시퀀스명.currval
	--------------------------
	● 시퀀스 삭제 SQL 구문
	--------------------------
		drop sequence 시퀀스명;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<12> 오라클을 연습하려면 어떤 SW를 설치해야 합니까 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	<1>개발자 용 오라클 버전(=OracleXE ) 을 설치한다. system 계정의 비밀번호는 123 으로 한다.
	<2>오라클 접속 툴의 한 종류인 Sqlgate 를 설치한다. 
	<3>Sqlgate 를 실행하고 아래 사항을 입력한 후 접속을 한다, 
		▶IP            => localhost
		▶사용자        => system
		▶암호          => 설정암호
		▶SID(서비스명) => XE

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<13> system 계정으로 접속하니 쓸 때 없는 테이블이 많아 번거롭네요.
	sysyem 계정과 동일한 권한을 가지는 새로운 계정을 만들려면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	① system 계정으로 접속한 후 코딩 창에서 아래 와 같은 명령으로 king 계정을 만들고 암호는 k123 으로 한다.
		create user king  identified by k123;
	② 아래 와 같은 명령으로 king 계정에 system 계정과 동일한 권한을 부여한다.
		grant connect,resource,dba to king;
	③ Sqlgate에서 king 계정으로 재 접속을 시도한 후 아래 사항을 입력한 후 접속을 한다, 
		●IP            => 127.0.0.1 또는 localhost
		●사용자        => king  
		●암호          => k123
		●SID(서비스명) => XE

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<14> 아래 고객 요구사항에 맞는 테이블을 만들면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	--------------------------------------------------------------------------------------------
	부서를 관리하고 싶어요
		 관리하고 싶은 정보는 부서명, 부서 위치 입니다.
	--------------------------------------------------------------------------------------------
	직원정보를 관리하고 싶어요
		관리하고 싶은 정보는 직원명, 직급, 입사일, 소속부서명, 연봉, 주민번호, 전화번호, 연봉등급, 직속상관명 입니다.
	--------------------------------------------------------------------------------------------
	고객정보를 관리하고 싶어요
		관리하고 싶은 정보는 고객명, 전화번호, 주민번호, 담당직원명 입니다.
	--------------------------------------------------------------------------------------------
	연봉등급을 관리하고 싶어요
		관리하고 싶은 정보는 연봉등급, 등급별 최소연봉, 등급별 최대연봉 입니다.
	--------------------------------------------------------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<15> employee 테이블에서 모든 컬럼, 모든행의 데이터를 검색하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■	
	-----------------------------------------------------------------------
	select emp.no, emp_name, dep_no, jikup, salary, hire_date, jumin_num, phone_num from employee;
	-----------------------------------------------------------------------
	select * from employee;
	-----------------------------------------------------------------------
	select
		emp_no
		, dep_no
		, jikup
		, salary
		, hire_date
		, jumin_num
		, phone_num
		, mgr_emp_no
	from
		employee;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<16> employee 테이블에서 emp_no. emp_name. jikup, salary, hire_date 컬럼의 데이터를 검색하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■	

	select
		emp_no, emp_name, jikup, salary, hire_date
	from
		employee;
		
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<17> employee 테이블에서 emp_no. emp_name. jikup, salary, hire_date 을 검색하면서
	별칭(=alias) 을 즉 헤더를 사원번호, 직원명, 직급, 연봉, 입사일로 하고 연봉에 '만원' 이란 문자를 붙여 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■	
	-------------------------------------------------------
	select
		emp_no		as "직원번호"
		, emp_name	as "직원명"
		, jikup		as "직급"
		, salary || '만원'	as "연봉"
		, hire_date	as "입사일"
	from
		employee;
	-------------------------------------------------------
		<참고> as 생략이 가능하다.
		<참고> 별칭에 공백이 없으면 "" 도 생략이 가능하다. 그치만 무조건 "" 는 사용하자.
		<참고> 오라클에서 연결 연산자는 +가 아니라 || 이다. 자바와 다르다.
		<참고> * 는 모든 값이지만 순서는 create로 테이블을 만들었던 순서임.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<18> employee 테이블에서 직원명, 직급, 연봉, 세금, 실수령액 을 검색하면 ? (세금은 연봉의 12%)
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	-------------------------------------------------------
	select
		emp_name		as "직원명"
		, jikup			as "직급"
		, salary || '만원'		as "연봉"
		, salary*0.12 || '만원'	as "세금"
		, salary*0.88 || '만원'	as "실수령액"
	from
		employee;
	-------------------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<19> employee 테이블에서 직급을 중복없이 검색하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	---------------------------------------------
	select distinct jikup from employee;             
	---------------------------------------------
	select unique jikup from employee;
	---------------------------------------------
	select distinct(jikup) from employee;
	---------------------------------------------
	select unique(jikup) from employee;
	---------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<20> employee 테이블에서 부서번호와 직급을 중복 없이 검색하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	---------------------------------------------
	select distinct dep_no, jikup from employee;
	---------------------------------------------
	select unique dep_no, jikup from employee;
	---------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<21> employee 테이블에서 연봉이 3000 이상인 직원을 검색하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	---------------------------------------------
	select * from employee where salary >= 3000
	---------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<22> employee 테이블에서 연봉 오름차순으로 검색하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	---------------------------------------------
	select * from employee order by salary ASC ;
	---------------------------------------------
	select * from employee order by salary ;
	---------------------------------------------
	select * from employee order by 5 ;
	---------------------------------------------
	select * from employee order by salary DESC ;
	---------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<23> employee 테이블에서 연봉 내림차순으로 검색하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	---------------------------------------------
	select * from employee order by salary desc;
	---------------------------------------------
	select * from employee order by 5 desc;
	---------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<24> employee 테이블에서 부서번호 오름차순을 유지하면서 연봉 내림차순으로 검색하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	---------------------------------------------
	select * from employee order by dep_no asc , salary desc;
	---------------------------------------------
	select * from employee order by dep_no , salary desc;
	---------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<25> employee 테이블에서 직급이 높은 순서 나열해서 검색하면 ? + 같은값일 시 연봉 내림차순
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	
	select * from employee order by decode ( jikup, '사장', 1, '부장', 2, '과장', 3, '대리', 4), salary desc ;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<26> employee 테이블에서 부장만 검색하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select * from employee where jikup = '부장';

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<27> employee 테이블에서 20번 부서의 과장을 검색하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select * from employee where dep_no = 20 and jikup = '과장';

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<28> employee 테이블에서 20번 부서 또는 과장을 검색하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select * from employee where dep_no = 20 or jikup = '과장';

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<29> employee 테이블에서 과장 중에 연봉 3400 이상을 검색하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select * from employee where jikup = '과장' and salary >= 3400;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<30> employee 테이블에서 실수령액이 4000만원 이상 받는 직원을 검색하면 ? (세금은 12%)
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select * from employee where salary*0.88 >= 4000;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<31> employee 테이블에서 세금을 제일 많이 내는 직원 순서로 나열하면서  부서번호가 내림차순이면서
	사장이 아닌 직원을 검색하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select * from employee where not jikup = '사장' order by salary*0.12 desc, dep_no desc ;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<32> employee 테이블에서 20번 부서 중에 연봉 2000~3000 사이 검색하면 ? 
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select * from employee where dep_no = 20 and salary between 2000 and 3000;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<33> employee 테이블에서 직속 상관이 없는 직원을 검색하면 ? 
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	
	select * from employee where mgr_emp_no is null;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<34> employee 테이블에서 직속 상관이 있는 직원을 검색하면 ? 
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	
	select * from employee where mgr_emp_no is not null;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<35> 오라클 4대 천왕 ? 
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	
	내장함수		=> 미리 만들어진 단위 프로그램으로 호출하면 특정 작업을 하고 데이터를 리턴한다.
	join (조인)	=> 서로 다른 테이블의 컬럼을 횡으로 붙이는 작업
	subquery		=> SQL 구문안의 select 문
	group by		=> 통계 관련 작업

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<36> employee 테이블에서 [최소 연봉], [최대 연봉], [평균 연봉], [연봉총합], [총인원수]를 검색하면 ? 
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select 
		min(salary)	as "최소연봉"	-- salary 컬럼에서 최소값을 리턴
		,max(salary)	as "최대연봉"	-- salary 컬럼에서 최대값을 리턴
		,avg(salary)	as "평균연봉"	-- salary 컬럼에서 평균값을 리턴
		,sum(salary)	as "연봉총합"	-- <조심> null 있으면 더할때 빠지고, 나누는 개수에서도 빠진다.
		,count(salary)	as "총인원수"	-- count ( * )는 총행의 개수
	from
		employee;
	-------------------------------------------------------------
	min, max, avg, sum, count 함수들은 [그룹함수] 또는 [통계함수] 라고 부르기도 한다.
	그룹지어서 연산을 하는 함수이기 때문이다.
	그룹함수들은 주로 group by와 같이 많이 사용된다.
	-------------------------------------------------------------
	min, max, avg, sum, count 함수들은 null 값은 제외하고 계산한다.
	-------------------------------------------------------------
	count(컬럼명) => 컬럼안의 null 아닌 데이터의 개수를 리턴한다.
	count(*)	=> 행의 개수를 리턴한다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<37> 아래 SQL 구문은 무슨 문제의 답인가 ?
	select count (emp_no) from customer 
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	담당 직원이 있는 고객의 명수는?

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<38> 고객을 담당하고 있는 직원의 명수는 ? 
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select count (distinct emp_no) from customer
	-------------------------------------------------------------
	distinct 컬럼명 => 컬럼 안의 데이터의 중복을 제거

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<39> 직속상관이 있는 직원의 명수는 ? 
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select count(mgr_emp_no) from employee;
	-------------------------------------------------------------
	<주의> mgr_emp_no 컬럼안의 데이터가 뭔지 먼저 파악해야한다. 바로 직속 상관의 직원번호 이다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<39-1> 부하직원이 있는 직원의 명수는 ? 
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select count(distinct mgr_emp_no) from employee;
	-------------------------------------------------------------
	distinct 컬럼명 => 컬럼 안의 데이터의 중복을 제거
	-------------------------------------------------------------
	<주의> count에는 업무적 특징이 숨어 있어 조심히 날려야한다. (고객 요구)

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<40> employee 테이블에서 [직원번호], [직원명], [생일월-생일일] 를 검색하면 ? 
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select
		emp_no						as "직원번호"
		,emp_name					as "직원명"
		,substr(jumin_num,3,2) || '-' || substr(jumin_num,5,2)	as "생일월일"
	from
		employee;
	-------------------------------------------------------------
	**** substr(컬럼명, 복사할 시작 순서번호, 복사할 개수) => 시작순서번호 부터 복사할 개수 만큼 복사해서 리턴하기
							엄청난 사용빈도를 자랑한다.
	-------------------------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<41> customer 테이블에서 모든 컬럼, 모든 행을 검색해서 출력하면 ?
	단, 주민번호는 901225-2****** 형태로 출력하세요. 
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	
	select
		cus_no
		,cus_name
		,tel_num
		,substr(jumin_num,1,6) || '-' || substr(jumin_num,7,1) || '******'
		,emp_no
	from
		customer;
	-------------------------------------------------------------
	<주의> 모든 행 이란 말이 나오면 where 절이 없다.
	-------------------------------------------------------------
	**** substr(컬럼명, 복사할 시작 순서번호, 복사할 개수) => 시작순서번호 부터 복사할 개수 만큼 복사해서 리턴하기
							엄청난 사용빈도를 자랑한다.
	-------------------------------------------------------------
	|| => 좌우의 문자열을 붙이는 연산자, 즉 연결 연산자이다. 
	<주의> 오라클에서 +는 연결 연산자가 아니라 사칙연산자 이다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<42> customer 테이블에서 고객번호, 고객명, 담당직원번호 를 출력하면 ?
	단 담당직원번호가 없으면 null 출력하지 말고 '없음' 으로 표시 
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select
		cus_no
		,cus_name
		,nvl(emp_no || '', '없음')
	from
		customer;
	---------------------------------------------
	nvl(컬럼명, null값일때 대체데이터)
	---------------------------------------------
	=>컬럼명 안의 데이터가 null이 아니면 그냥 리턴하고
				null 이면 null값일때 대체데이터를 리턴하는 [null 처리 내장함수] 이다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<43> customer 테이블에서 고객번호, 고객명, 담당직원존재여부 를 출력하면?
	단 직원번호가 있으면 '있음', 없으면 '없음'으로 표시 
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select
		cus_no
		,cus_name
		,nvl2(emp_no, '있음', '없음')
	from
		customer;	
	---------------------------------------------
	nvl2(컬럼명, null값 아닐때 대체데이터, null값일때 대체데이터)
	---------------------------------------------
	=> 컬럼명 안의 데이터가 null이 아니면 null값 아닐때 대체데이터 출력하고
		null이면 null값 일때 대체데이터를 리턴하는 [null 처리 내장함수] 이다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<44> employee 테이블에서 직원번호, 직원명, 직급, 성별을 출력하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select
		emp_no
		,emp_name
		,jikup
		,case 
			substr(jumin_num,7,1) 
			when '1' then '남'
			when '3' then '남' 
			when '2' then '여' 
			when '4' then '여' 
		end
	from
		employee;
	-----------------------------------------------------
	select
		emp_no
		,emp_name
		,jikup
		,case
			substr(jumin_num,7,1)
			when '1' then '남'
			when '3' then '남'
			else '여'
		end
	from
		employee;
	-----------------------------------------------------
	select
		emp_no
		,emp_name
		,jikup
		,case
			when substr(jumin_num,7,1) = '1' then '남'
			when substr(jumin_num,7,1) = '3' then '남'
			else '여'
		end
	from
		employee;
	-----------------------------------------------------
	select
		emp_no
		,emp_name
		,jikup
		,decode(
			substr(jumin_num,7,1)
			, '1', '남'
			, '3', '남'
			, '여'
		)
	from
		employee;
	-------------------------------------------------------------
	case 컬럼명
		when 데이터1 then 리턴값1
		when 데이터2 then 리턴값2
		~
		else 리턴값n
	end
	-------------------------------------------------------------
		컬럼명 안의 데이터가 데이터1과 같으면 리턴값1을 리턴
		컬럼명 안의 데이터가 데이터2와 같으면 리턴값2를 리턴
		~
		그외에는 리턴값n 을 리턴하기
	-------------------------------------------------------------
	case
		when 컬럼명 = 데이터1 then 리턴값1
		when 컬럼명 >= 데이터2 then 리턴값2
		~
		else 리턴값n
	end
	-------------------------------------------------------------
		컬럼명 안의 데이터가 데이터 1과 같으면 리턴값 1을 리턴
		컬럼명 안의 데이터가 데이터 2보다 크면 리턴값 2를 리턴
	-------------------------------------------------------------
		비교 연산자 사용가능 >=, <=, <, >, != 등등
		else 리턴값n 은 생략가능
	
	*************************************
	decode(~) 구문의 패턴 설명
	*************************************
		decode(
			컬럼명
			, 비교데이터1, 리턴값1
			, 비교데이터2, 리턴값3
			, ~	,~
			, 리턴값n
		)
		-------------------------------------------------------------
			컬럼명 안의 데이터가 데이터1과 같으면 리턴값1을 리턴
			컬럼명 안의 데이터가 데이터2와 같으면 리턴값2를 리턴
			~
			그외에는 리턴값n 을 리턴하기
		-------------------------------------------------------------
			필요에 따라 그외경우 리턴값n 은 생략될 수 있다.
			decode 단점
				=> 같다라는 경우에만 사용된다.
				=> 오라클에서만 사용되는 오라클 전용함수이다. case 구문은 모든 DB에서 사용가능하다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<45> employee 테이블에서 직원번호, 직원명, 직급, 출생년도(4자리) 를 출력하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	
	select
		emp_no
		,emp_name
		,jikup
		,case 
			when substr(jumin_num,7,1) = '1' then '19'
			when substr(jumin_num,7,1) = '2' then '19'
			else '20'
		 end || substr(jumin_num,1,2)

	from
		employee;
	-------------------------------------------------------
	select
		emp_no
		,emp_name
		,jikup
		,decode(
			substr(jumin_num,7,1)
			, '1', '19'
			, '2', '19'
			, '20'
		)  || substr(jumin_num,1,2)
	from
		employee;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<46> employee 테이블에서 직원번호, 직원명, 직급, 출생년대(4자리) 를 출력하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

		select
		emp_no
		,emp_name
		,jikup
		,case 
			when substr(jumin_num,7,1) = '1' then '19'
			when substr(jumin_num,7,1) = '2' then '19'
			else '20'
		 end || substr(jumin_num,1,1) || '0년대'

	from
		employee;
	-------------------------------------------------------
	select
		emp_no
		,emp_name
		,jikup
		,decode(
			substr(jumin_num,7,1)
			, '1', '19'
			, '2', '19'
			, '20'
		)  || substr(jumin_num,1,1) || '0년대'
	from
		employee;
	-------------------------------------------------------------
	<참고> 년도 => 1년 단위, 년대 => 10년 단위

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<47> employee 테이블에서 나이순으로 출력하면 ? 연장자가 먼저 나오도록
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select
		*
	 from 
		employee
	order by
		case
			when substr(jumin_num,7,1)='1' then '19'
			when substr(jumin_num,7,1)='2' then '19'
			else '20'
		end || substr(jumin_num,1,6)
	asc ;
	-------------------------------------------------------------
	아래처럼 하면 안된다. 200년생이 먼저 나온다. 2000년 생은 주민번호가 00으로 시작한다.
	-------------------------------------------------------------
	select * from employee order by jumin_num asc;
	-------------------------------------------------------------
	order by 뒤는 정렬 기준 컬럼이 나온다. 정렬 기준 컬럼을 case가 끌어안아서 정렬 기준을 바꾼것이다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<48> employee 테이블에서 직급 순서대로 정렬하여 모든 컬럼을 보이면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select 
		*
	from
		employee
	order by
		case jikup
			when '사장' then 1
			when '부장' then 2
			when '과장' then 3
			when '대리' then 4
			when '주임' then 5
			else 6
		end
	asc;
	-------------------------------------------------------------
	select * from employee
	order by
		decode(
			jikup
			,'사장',1
			,'부장',2
			,'과장',3
			,'대리',4
			,'주임',5
			,6
		) asc;
	-------------------------------------------------------------
	order by 뒤는 정렬 기준 컬럼이 나온다. 정렬 기준 컬럼을 case가 끌어 안아서 다른 형태로 바꾼것이다.
	-------------------------------------------------------------
	정렬시 사장은 1로보고, 부장은 2로보고, 과장은 3으로보고, 대리는 4로보고, 주임은 5로보고, 기타는 6으로보고
	오름차순으로 정렬한다. 즉 직급을 정수로 바꾸어서 정렬을 한 것이다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<49> employee 테이블에서 직원번호, 직원명, 입사일(연-월-일(요일) 분기 시 분 초) 검색하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select
		emp_no
		,emp_name
		,to_char(hire_date,'YYYY-MM-DD(DY) Q AM HH:MI:SS' , 'NLS_DATE_LANGUAGE = Korean')
		,to_char(hire_date,'YYYY-MM-DD(DAY) HH24:MI:SS' , 'NLS_DATE_LANGUAGE = Korean')
	from
		employee;
	-------------------------------------------------
	to_char ( 날짜또는 숫자, '출력 문자패턴' )
		지정한 날짜또는 숫자를 원하는 출력 문자패턴으로 바꿔주는 변환함수
			YYYY	=> 년도 4자리		MI SS	=> 분 초
			MM	=> 월 2자리		DY 	=> 영문 요일 약어
			DD 	=> 일 2자리		DAY 	=> 영문 요일 풀네임
			AM HH	=> 오전 | 오후 2자리	HH24	=> 0~23 사이의 시간
			Q	=> 분기
	-------------------------------------------------
	to_char ( hire_date, 'YYYY-MM-DD' )
	-------------------------------------------------
		hire_date 컬럼안의 데이터를 년-월-일 패턴의 문자열로 바꾸어 리턴하라

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<49-2> employee 테이블에서 직원번호, 직원명, 입사일(X년-X월-X일(요일) X분기 X시 X분 X초) 검색하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select
		emp_no
		,emp_name
		,to_char(hire_date,'YYYY"년"MM"월"DD"일"(DY) Q"분기" AM HH"시"MI"분"SS"초"' , 'NLS_DATE_LANGUAGE = Korean')
	from
		employee;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<50> employee 테이블에서 직원번호, 직원명, 나이 검색하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select
		emp_no
		,emp_name
		, to_number(to_char(sysdate,'YYYY'))
		  - to_number(
			case substr(jumin_num,7,1)
			when '1' then '19'
			when '2' then '19'
			else '20'
			end
			|| substr(jumin_num, 1, 2)
		) +1 || '세'
	from
		employee;
	-----------------------------------------------------
	to_number(숫자문자내장된 컬럼명) => 컬럼명 안의 숫자 문자를 숫자로 변경하는 변환함수
	-----------------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<51> employee 테이블에서 직원번호, 직원명, 근무년차 검색하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select
		emp_no		"직원번호"
		,emp_name	"직원명"
		,
	from
		employee;
	------------------------------------------------------
	select
		emp_no				"직원번호"
		,emp_name			"직원명"
		,ceil((sysdate-hire_date)/365)	|| '년차'	"근무년차"
	from
		employee;
	------------------------------------------------------
	오라클은 날짜-날짜 의 결과값은 날짜차이만큼의 일수이다.
	ceil(~)	=> 소수 첫째 자리에서 무조건 올림해서 리턴하는 수학 함수의 일종이다.
	floor(~)	=> 소수 첫째 자리에서 무조건 내림해서 리턴하는 수학 함수의 일종이다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<52> employee 테이블에서 직원번호, 직원명, 연령대를 검색하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	
	select
		emp_no
		,emp_name
		,
		floor(
			(
				to_number(to_char(sysdate,'YYYY'))
				- to_number (
						case substr(jumin_num,7,1)
							when '1' then '19'
							when '2' then '19'
							else '20'
						end || substr(jumin_num,1,2)
				)+1
			)*0.8
		) || '0대'
	from
		employee;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<53> employee 테이블에서 직원번호, 직원명, 100일잔치날짜를 검색하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■	

	select
		emp_no
		,emp_name
		,to_date'19' || substr(jumin_num,1,6), 'YYYYMMDD') +100
	from
		employee;
	-----------------------------------------------------
	select
		emp_no
		,emp_name
		,to_char(
			to_date(
				case when substr(jumin_num,7,1) in ('1','2') then '19' else '20' end
					|| substr(jumin_num,1,6)
				'YYYYMMDD'
				)+ 100
			, 'YYYY-MM-DD(DY)'
		)
	from
		employee;
	-----------------------------------------------------
	날짜 + 정수 => 날짜에 정수만큼의 일수를 더한 날짜를 리턴.
	날짜 - 정수 => 날짜에 정수만큼의 일수를 뺀 날짜를 리턴.
	날짜1 - 날짜2 => 날짜1과 날짜2 까지의 차이를 일수로 리턴. 일수 양수가 날짜1이 날짜2보다 큰 거다
	날짜1 + 날짜2 => 이런거 없다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<54> 개강일이 2021년 5월 12일 이고 종강일이 2021년 11월 10일 이다
	며칠 동안 학원 생활을 하나?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	
	select
		to_date ('20211110','YYYYMMDD')
		-
		to_date ('20210512','YYYYMMDD')
	from
		dual;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<55> employee 테이블에서 직원번호, 직원명, 현재나이, 입사당시나이 를 검색하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select
		emp_no
		,emp_name
		,to_number(sysdate,'YYYY')
		- to_number(
				case substr(jumin_num,7,1)
				when '1' then '19' 
				when '2' then '19' 
				else '20' 
			end || substr(jumin_num,1,2) +1 || '세'	as"현재나이"
		, to_number(to_char(hire_date,'YYYY'))
		-to_number(
				case substr(jumin_num,7,1)
				when '1' then '19' 
				when '2' then '19' 
				else '20' 
			end || substr(jumin_num,1,2) +1 || '세'	as"입사일 당시나이"
		
	from
		employee;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<56> employee 테이블에서 직원번호, 직원명, 주민번호, 다가올 생일날 ( 년-월-일), 생일까지 남은일수 를 검색하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select
		emp_no
		,emp_name
		,jumin_num
		,to_date(
			to_char(sysdate,'YYYY') || substr(jumin_num,3,4)
			, 'YYYYMMDD'
		)
		-
		sysdate
		>= 0
	then
		to_char(
			to_date(
				to_char(sysdate,'YYYY') || substr(jumin_num,3,4)
				, 'YYYYMMDD'
			)
			,'YYYY-MM-DD'
		)
		--올해 생일을 년-월-일 로 리턴하는 식
	else
		to_char(
			to_date(
				to_number(to_char(sysdate,'YYYY'))+1 || substr(jumin_num,3,4)
				, 'YYYYMMDD'
			)
			,'YYYY-MM-DD (dy)'
		)
		--내년 생일을 년-월-일 로 리턴하는 식
	end	"다가올 생일날"
	
	,case when
		to_char(
			to_date(
				to_char(sysdate,'YYYY') || substr(jumin_num,3,4)
				, 'YYYYMMDD'
			)
			-
			sysdate
			>= 0
	then
		to_date(
				to_char(sysdate,'YYYY') || substr(jumin_num,3,4)
				, 'YYYYMMDD'
			)
			-
			sysdate
	else
		to_date(
			extract(year from sysdate)+1 || substr(jumin_num,3,4)
			, 'YYYYMMDD'
		)
		-
		sysdate
	end	"생일까지 남은일수"
	from
		employee;
	order by	5 asc;
	
	------------------------------------------------
	생일까지 남은일수 계산 방법
	------------------------------------------------
		만약 올해 생일날짜 - 지금날짜 값이 양수면 생일이 안지났으므로 올해 생일날짜 - 지금날짜면 된다.
		만약 올해 생일날짜 - 지금날짜 값이 음수면 생일이 지났으므로 내년 생일날짜 - 지금날짜면 된다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<57> employee 테이블에서 직원번호, 직원명, 직급, 연봉(xxx,xxx,xxx 만원)을 검색하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select
		emp_no
		,emp_name
		,jikup
		,to_char(salary, '999,999,999')
	from
		employee;
	------------------------------------------------
	to_char(salary,'999,999,999') => salary 컬럼안의 숫자를 3자리마다 끊어서 , 를 삽입해서 문자로 리턴하기
					만약 각 9자리에 대응하는 숫자 없으면 화면에 출력이 안된다.
	------------------------------------------------
	to_char(salary,'099,999,999') => salary 컬럼안의 숫자를 3자리마다 끊어서 , 를 삽입해서 문자로 리턴하기
					맨앞에 0 이 있으면 그자리가 비면 0 이 대체된다. 따라서 나머지도 9이어도
					다 0 으로 대체된다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<58> employee 테이블에서 수요일에 태어난 직원을 검색하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	
	select * from employee
	where to_char (
			to_date(
				decode(substr(jumin_num,7,1),'1','19','2','19','20')||substr(jumin_num,1,6)
				,'YYYYMMDD'
			)
			, 'DAY'
			,'NLS_DATE_LANGUAGE = Korean'
		)
		= '수요일'

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<59> employee 테이블에서 70년대생 남자 직원을 검색하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select * from employee
	where substr(jumin_num, 1 ,1) = '7' and
		(substr(jumin_num, 7, 1) = '1' or substr(jumin_num, 7, 1) = '3') ;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<60> employee 테이블에서 60년대, 70년대생 남자 직원을 검색하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select * from employee
	where (substr(jumin_num, 1 ,1) = '6' or substr(jumin_num, 1 ,1) = '7') and
		(substr(jumin_num, 7, 1) = '1' or substr(jumin_num, 7, 1) = '3') ;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<61> employee 테이블에서 오래 근무한 직원이 먼저 나오게 검색하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select * from employee order by (sysdate-hire_date)
	desc;
	------------------------------------------------
	sysdate-hire_date => 지금날짜 - 입사일 날짜에서 날짜를 빼면 차이만큼 일수를 리턴한다..

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<62> employee 테이블에서 직원번호, 직원명, 근무일수, 근무개월수, 입사후 5개월후 날짜(년-월-일), 입사한 달의 마지막 날짜 
			, 입사한날짜기준 돌아오는 일요일날짜 검색하면 ? 근무일수는 소수 2자리에서 반올림해라
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select 
		emp_no						"직원번호"
		,emp_name					"직원명"
		,round(sysdate-hire_date,1)				"근무일수"
		,months_between(sysdate, hire_date)			"근무개월수"
		,to_char(add_months(hire_date,5),'YYYY-MM-DD')	"입사후 5개월후 날짜(년-월-일)"
		,to_char(last_day(hire_date),'YYYY-MM-DD')		"입사한 달의 마지막 날짜"
		,to_char(next_day(hire_date,1), 'YYYY-MM-DD')		"입사한날짜기준 돌아오는 일요일날짜"
	from
		employee;
	-----------------------------------------------
	months_between( 날짜1 , 날짜2 ) => 날짜1과 날짜2의 차이를 개월수로 리턴
	-----------------------------------------------
	add_months( 날짜 , 개월수 ) => 날짜에 개월수 만큼 더한 날의 날짜를 리턴
	-----------------------------------------------
	last_day( 날짜 ) => 날짜가 속한 달의 마지막 날짜를 리턴
	-----------------------------------------------
	next_day( 날짜 , 요일정수 ) => 날짜 기준으로 돌아오는 요일의 날짜를 리턴하기
					요일 정수는 1~7(일~토)
	-----------------------------------------------
	날짜1 - 날짜2 => 날짜1과 날짜2의 차이를 일수로 리턴하기
	-----------------------------------------------
	날짜 + 정수 => 날짜에다 정수만큼의 일수를 더한 날의 날짜를 리턴하기
	-----------------------------------------------
	날짜 - 정수 => 날짜에다 정수만큼의 일수를 뺀 날의 날자를 리턴하기
	-----------------------------------------------
	round( 숫자저장컬럼명, 반올림한후 보여지는 소수자리수) => round(sysdate-hire_date,1)
								소수2번째 자리에서 반올림
	-----------------------------------------------
	trunc( 숫자저장컬럼명, 버린후 보여지는 소수자리수) => trunc(sysdate-hire_date,1)
								소수2자리 이후는 모두 버리고 리턴

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<63> employee 테이블에서 직급이 과장이 아닌 직원을 검색하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	
	select * from employee where jikup != '과장';
	select * from employee where jikup <> '과장';


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<64> employee 테이블에서 부서번호가 10번이고 직급이 과장인 직원을 검색하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select * from employee where dep_no = 10 and jikup = '과장';

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<65> employee 테이블에서 직급이 과장이 또는 부장인 직원을 검색하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select * from employee where jikup in ('과장','부장');
	select * from employee where jikup = any('과장','부장');

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<66> employee 테이블에서 10번, 20번 부서 중에 직급이 과장인 직원을 검색하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select * from employee where (dep_no = 10 or dep_no =20) and jikup = '과장' ;
	select * from employee where dep_no in(10,20) and jikup = '과장';


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<67> customer 테이블에서 담당직원이 없는 고객을 검색하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select * from customer where emp_no is null;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<68> customer 테이블에서 담당직원이 있는 고객을 검색하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select * from customer where emp_no is not null;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<69> customer 테이블에서 담당직원 번호가 9번이 아닌 고객을 검색하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select * from customer where emp_no <> 9 or emp_no is null;
	-------------------------------------------
	<주의> emp_no is null 조건도 붙이는 이유는 emp_no가 NULL 일 경우
		emp_no != 9 조건에 포함되지 않기 때문이다.
		즉 NULL은 is null 또는 is not nll 연산자에 의해서만 검색된다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<70> employee 테이블에서 연봉이 3000만원 ~ 4000만원 사이인 직원을 검색하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select * from employee where salary >= 3000 and salary <= 4000;
	select * from employee where salary between 3000 and 4000;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<71> employee 테이블에서 연봉이 3000만원이상 4000만원 미만 검색하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select * from employee where salary between 3000 and 4000; and salary != 4000;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<72> employee 테이블에서 연봉을 5% 인상했다고 가정하고 3000이상인 직원을 검색하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select * from employee where salary * 1.05 >= 3000;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<73> employee 테이블에서 입사일이 '1995-1-1' 이상인 직원을 검색하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select * from employee where hire_date >= to_date('1995-1-1', 'YYYY-MM-DD');

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<74> employee 테이블에서 입사일이 1990년~1999년 사이인 직원을 검색하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select * from employee where hire_date>=to_date('1990-1-1','YYYY-MM-DD') and hire_date<to_date('1990-1-1','YYYY-MM-DD')

	select * from employee where to_number(to_char(hire_date,'YYYY')) between 1990 and 1999;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<75> employee 테이블에서 부서번호가 10번 또는 30번인 직원 중에 연봉이 3000 미만이고
		입사일이 '1996-1-1' 미만 직원을 검색하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select * from employee where
			(dep_no = 10 or dep_no = 30)
			and salary < 3000
			and hire_date<to_date('1996-01-01','YYYY-MM-DD');
	---------------------------------------------------------
	select * from employee where
			dep_no in(10,30)
			and salary < 3000
			and hire_date<to_date('1996-01-01','YYYY-MM-DD');
	---------------------------------------------------------
	select * from employee where
			dep_no = any(10,30)
			and salary<3000
			and hire_date< to_date('1996-01-01','YYYY-MM-DD');

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<76> employee 테이블에서 성이 김씨인 직원을 검색하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	
	select * from employee where substr(emp_name,1,1)='김';
	select * from employee where emp_name like '김%';
	-----------------------------------------------
	where 컬럼명 like '패턴문자열' => 컬럼명 안의 데이터가 패턴문자열을 갖고 있으면 그 행을 검색하라
	emp_name like '김%'
		=> 김이 첫글자고 두번째는 무엇이와도 좋고 길이에 제한이없다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<77> employee 테이블에서 성이 황씨인 직원을 검색하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select * from employee where
		substr(emp_name,1,1)='황' and substr(emp_name,1,2) =! '황보';
	---------------------------------------------------------
	select * from employee where
		where emp_name like '황%' and emp_name not like '황보%'

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<78> employee 테이블에서 이름이 2자인 직원을 검색하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select * from employee where length(emp_name)=2;
	-----------------------------------------------------
	length(컬럼명) => 컬럼명 안의 문자데이터의 길이를 리턴해주는 함수

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<79> employee 테이블에서 이름이 김으로 끝나는 직원을 검색하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select * from employee where emp_name like '%김';
	select * from employee where substr(emp_name, length(emp_name),1)='김';

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<80> employee 테이블에서 성이 김씨이고 3글자인 직원을 검색하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select * from employee where substr(emp_name,1,1)='김' and length(emp_name)=3;
	select * from employee shere emp_name like '김%' and length(emp_name)=3;
	select * from employee where emp_name like '김__';

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<81> employee 테이블에서 이름에 김이란 문자를 가진 직원을 검색하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select * from employee where emp_name like '%김%';

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<82> employee 테이블에서 성이 김씨가 아닌 직원을 검색하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select * from employee where emp_name not like '김%';

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<83> employee 테이블에서 이름 중간에만 김이 들어간 직원을 검색하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select * from employee
	where
		emp_name like '%김%'
		and emp_name not like '김%'
		and emp_name not like '%김';

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<84> employee 테이블에서 여자 직원을 검색하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select * from employee where substr(jumin_num,7,1) in('2','4');
	
	select * from employee where
		jumin_num like '______2%' or jumin_num like '______4%' ;
	
	select * from employee where
		jumin_num not like '______1%' or jumin_num not like '______3%' ;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<85> employee 테이블에서 1960년대, 1970년대 출생자중 남자만 검색하라 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select * from employee where
	(substr(jumin_num,1,1)='6' or substr(jumin_num,1,1)='7') and substr(jumin_num,7,1)='1';
	--------------------------------------------------------------------
	select * from employee where
	substr(jumin_num,1,1) in('6','7') and substr(jumin_num,7,1)='1';
	--------------------------------------------------------------------
	select * from employee where
		jumin_num like '6_____1%' or jumin_num like '7_____1%'




■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<86> join(조인) 이 뭡니까 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	▶ 2개 이상의 테이블로부터 연관성 있는 컬럼을 복사해서 횡으로 붙이는 작업을 말한다. (종으로 붙이면 유니온)
	
	▶ 예> 아래 직원번호와 직원명은 employee 테이블 소속이고, 소속부서명은 dept 테이블 소속이다
		-----------------------------------------
		직원번호	직원명	소속부서명
		-----------------------------------------
		1	홍길동	총무부

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<87> join(조인) 이 뭡니까 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	------------------------------------
	inner join
	------------------------------------
		▶ 조인 조건에 맞는 행만 포함하는 조인. 대부분이 이 조인이다. (= 내부조인이라고도 한다.)
	------------------------------------
	outer join
	------------------------------------
		▶ 조인 조건에 만족하지 못한 행도 출력하는 조인이다.
	------------------------------------
	self join
	------------------------------------
		▶ 1개의 테이블을 2개 이상으로 보고 하는 조인이다.
	------------------------------------
	cross join
	------------------------------------
		▶ 2개 이상 테이블에서 각각의 행이 모두 연결되는 조인이다. 연결 조건이 생략된다.
		▶ 잘 사용되지 않는 조인이다.
	
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<88> join(조인)에는 ANSI 조인형식과 오라클 조인이 있다는데 뭡니까 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	
	------------------------------------
	ANSI 조인
	------------------------------------
		모든 DB업체에서 공용으로 사용되는 조인이다.
	------------------------------------
	오라클 조인
	------------------------------------
		오라클에서만 사용되는 조인이다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<89> 직원번호, 직원명, 소속부서명 검색하라 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	------------------------------------
	<오라클 inner 조인> 테이블에 별칭을 주고 조인한것
	------------------------------------
	select
		e.emp_no
		,e.emp_name
		,d.dep_name
	from
		employee e, dept d
	where
		e.dep_no = d.dep_no ;

	------------------------------------
	<ANSI inner 조인>
	------------------------------------
	select
		e.emp_no
		,e.emp_name
		,d.dep_name
	from
		employee e inner join dept d
	on
		e.dep_no = d.dep_no;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<90> 고객명, 고객전화번호, 담당직원명, 담당직원직급 검색하라 ? <조건> 담당직원이 있는 고객만 출력
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	------------------------------------
	<주의> 담당직원이 있는 고객만 나와야하므로, 즉 조건에 맞는 행만 나와야하므로 inner조인이다.
	------------------------------------
	오라클 조인
	------------------------------------
	select
		c.cus_no		"고객번호"
		,c.tel_num	"고객명"
		,e.emp_name	"담당직원이름"
		,e.jikup		"담당직원직급"
	from
		customer c, employee e
	where
		c.emp_no = e.emp_no ;
	------------------------------------
	ANSI 조인
	------------------------------------
	select
		c.cus_no		"고객번호"
		,c.tel_num	"고객명"
		,e.emp_name	"담당직원이름"
		,e.jikup		"담당직원직급"
	from
		customer c inner join employee e
	on
		c.emp_no = e.emp_no ;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<91> 고객명, 고객전화번호, 담당직원명, 담당직원직급 검색하라 ? <조건> 10번부서의 담당직원이 있는 고객만 출력
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	------------------------------------
	오라클 조인
	------------------------------------
	select
		c.cus_no		"고객번호"
		,c.tel_num	"고객명"
		,e.emp_name	"담당직원이름"
		,e.jikup		"담당직원직급"
	from
		customer c, employee e
	where
		c.emp_no = e.emp_no and e,dep_no = 10 ;
	------------------------------------
	<주의> 오라클 조인에서는 where 절에 조인 조건과 행을 골라내는 조건이 같이 나올수있다.
		and로 연결하면된다.
	------------------------------------
	ANSI 조인
	------------------------------------
	select
		c.cus_no		"고객번호"
		,c.tel_num	"고객명"
		,e.emp_name	"담당직원이름"
		,e.jikup		"담당직원직급"
	from
		customer c inner join employee e
	on
		c.emp_no = e.emp_no
	where	
		e,dep_no = 10 ;
	------------------------------------
	<주의> ANSI 조인에서는 on 절에 조인 조건을 쓰고, where 절에 행을 골라내는 조건을 쓴다.
	------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<92> 고객명, 고객전화번호, 담당직원명, 담당직원직급 검색하라 ? 
	<조건> 연봉이 3000만원 이상인 담당직원이 있는 고객만 출력
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	------------------------------------
	오라클 조인
	------------------------------------
	select
		c.cus_no		"고객번호"
		,c.tel_num	"고객명"
		,e.emp_name	"담당직원이름"
		,e.jikup		"담당직원직급"
	from
		customer c, employee e
	where
		c.emp_no = e.emp_no and e.salary >= 3000;
	------------------------------------
	ANSI 조인
	------------------------------------
	select
		c.cus_no		"고객번호"
		,c.tel_num	"고객명"
		,e.emp_name	"담당직원이름"
		,e.jikup		"담당직원직급"
	from
		customer c inner join employee e
	on
		c.emp_no = e.emp_no
	where	
		e.salary >= 3000;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<93> 직원부서명, 직원명, 직원직급, 담당고객명,고객전화를 검색하라 ? <조건> 직원이름 오름차순 출력
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	
	------------------------------------
	오라클 조인
	------------------------------------
	select
		d.dep_name	"직원부서명"
		,e.emp_name	"직원명"
		,e.jikup		"직원직급"
		,c.cus_name	"담당고객명"
		,c.tel_num	"고객전화번호"
	from
		employee e, dept d, customer c 
	where
		e.dep_no = d.dep_no and e.emp_no = c.emp_no
	order by
		e.emp_name asc;
	------------------------------------
	ANSI 조인
	------------------------------------	
	select
		d.dep_name	"직원부서명"
		,e.emp_name	"직원명"
		,e.jikup		"직원직급"
		,c.cus_name	"담당고객명"
		,c.tel_num	"고객전화번호"
	from
		(employee e inner join dept d  on  e.dep_no=d.dep_no)
		inner join customer c on c.emp_no = e.emp_no
	order by
		e.emp_name asc;
				* ANSI 형식은 3개 테이블 이상부터 코드가 길어짐

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<94> 직원부서명, 직원명, 직원직급, 연봉등급을 검색하라 ? 
	<조건> 연봉등급 오름차순, 직급높은순서 오름차순, 나이높은순서 내림차순
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	------------------------------------
	오라클 조인
	------------------------------------
	select
		e.emp_name, e.jikup, d.dep_name, s.sal_grade_no
	from
		employee e, dept d, salary_grade s
	where
		e.dep_no = d.dep_no and (e.salary between s.min_salary and s.max_salary)
	order by
		s.sal_grade_no asc
		,decode(e.jikup,'사장',1,'부장',2,'과장',3,'대리',4,'주임',5,6) asc
		,case when substr(e.jumin_num,7,1) in('1','2') then '19' else '20' end || substr(e.jumin_num,1,6) asc;
	------------------------------------
	ANSI 조인
	------------------------------------
	select
		e.emp_name, e.jikup, d.dep_name, s.sal_grade_no
	from
		(dept d inner join employee e on d.dep_no = e.dep_no) inner join
		 salary_grade s on (e.salary between s.min_salary and s.max_salary)
	order by
		s.sal_grade_no asc
		,decode(e.jikup,'사장',1,'부장',2,'과장',3,'대리',4,'주임',5,6) asc
		,case when substr(e.jumin_num,7,1) in('1','2') then '19' else '20' end || substr(e.jumin_num,1,6) asc;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<95> 부하직원명, 부하직원직급, 직속상관명, 직속상관직급 검색하라 ? <조건> 상관이 있는 직원만 포함
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	
	------------------------------------
	self 조인
	------------------------------------
	select
		e1.emp_name	"직원명"
		,e1.jikup	"직원직급"
		,e2.emp_name	"직속상관명"
		,e2.jikup	"식속상관직급"
	from
		employee e1, employee e2
	where
		e1.mgr_emp_no = e2.emp_no

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<96> 직속상관명, 직속상관직급, 부하직원명, 부하직원직급 검색하라 ? <조건> 상관이 있는 직원만 포함
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select
		e1.emp_name	"직속상관명"
		,e1.jikup	"식속상관직급"
		,e2.emp_name	"직원명"
		,e2.jikup	"직원직급"
	from
		employee e1, employee e2
	where
		e1.emp_no = e2.mgr_emp_no

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<97> 직원명, 직원직급, 소속부서명, 연봉등급, 직속상관명, 직속상관직급, 담당고객명을 검색하라 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select
		e1.emp_name
		,e1.jikup
		,d.dep_name
		,s.sal_grade_no
		,e2.emp_name
		,e2.jikup
		,c.cus_name
	from
		employee e1, dept d, salary_grade s, employee e2, customer c
	where
		e1.dep_no = d.dep_no
		and (e1.salary>=s.min_sal and e1.salary<=s.max_sal)
		and e2.emp_no=e1.mgr_emp_no
		and e1.emp_no=c.emp_no;
	------------------------------------------------------------
	select
		e.emp_name
		,e.jikup
		,d.dep_name
		,s.sal_grade_no
		,e2.emp_name
		,e2.jikup
		,c.cus_name
	from
		(((employee e inner join dept d on e.dep_no = d.dep_no) 
		inner join salary_grade s on e.salary between s.min_salary and s.max_salary)
		inner join employee e2 on e.mgr_emp_no = e2.emp_no)
		inner join customer c on c.emp_no = e.emp_no

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<98> 고객명, 고객전화번호, 담당직원명, 담당직원직급을 검색하라 ? <조건> 담당직원이 없는 고객도 포함
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	------------------------------------------------------------
	<주의> 담당직원이 없는 고객도 포함 하라는 얘기는 고객은 다 나오라는 말이다. 즉 outer 조인 하라는 말이다.
	outer 조인은 한쪽은 다 나오는 조인이다. 나머지는 조건에 안맞더라도 null 달고라도 나오라는 조인이다.
	------------------------------------------------------------
	select
		c.cus_name	"고객명"
		,c.tel_num	"고객전화번호"
		,e.emp_name	"담당직원명"
		,e.jikup	"담당직원직급"
		,e.dep_np	"부서번호"
	from
		customer c, employee e
	where
		c.emp_no = e.emp_no(+)
	------------------------------------------------------------
	▶ c.emp_no = e.emp_no(+) 의미
		(+)가 붙은 컬럼의 반대편 컬럼의 소속 테이블 행은 모두 나오고
		(+)가 붙은 e.emp_no 컬럼의 소속 테이블 행은 조건에 맞는 게 없으면 null 이라도 달고 나오라는 뜻
		c.emp_no = e.emp_no(+)
	------------------------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<99> 고객번호, 고객명, 고객전화번호, 담당직원명, 담당직원직급을 검색하라 ? 
	<조건> 고객정보는 모두 보이고 직원정보는 10번 부서만 보일 것
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	------------------------------------
	오라클 조인
	------------------------------------
	select
		c.cus_no
		,c.cus_name
		,c.tel_num
		,e.emp_name
		,e.jikup
		,e.dep_no
	from
		customer c, employee e
	where
		c.emp_no = e.emp_no(+) and e.dep_no(+)=10;
	------------------------------------------------------------
	<주의> outer 조인에서 where에 (+)가 붙는 놈은?
	------------------------------------------------------------
		다나오는 메인테이블에 딸려 나오는 즉 메인테이블이 아닌 모든컬럼에 붙는다.
		심지어 행을 골라내는 조건의 컬럼도 여기에 속한다.
	------------------------------------------------------------
	만약 e.dep_no(+)=10을 e.dep_no=10 로 수정하면?
	------------------------------------------------------------
		담당직원이 10번 부서인 고객만 포함된다.
		마치 inner 조인의 결과 처럼 보인다.

	------------------------------------
	ANSI 조인
	------------------------------------
	select
		c.cus_no
		,c.cus_name
		,c.tel_num
		,e.emp_name
		,e.jikup
		,e.dep_no
	from
		customer c left outer join employee e
	on
		c.emp_no = e.emp_no and e.dep_no=10;
	------------------------------------------------------------
	<주의> ANSI 조인에서 left outer join 나오면 left outer join 왼쪽에 있는 테이블이 다 나오는 테이블이다.
	------------------------------------------------------------
	<주의> ANSI 조인에서 right outer join 나오면 right outer join 오른쪽에 있는 테이블이 다 나오는 테이블이다.
	------------------------------------------------------------
	------------------------------------------------------------
	만약 e.dep_no=10을 따로 빼내서 where e.dep_no=10으로 추가하면?
	------------------------------------------------------------
		where 절이 있으면 행을 골라내므로 고객이 2명만 나온다.
		ANSI 방식의 outer 조인에서는 행을 골라내는 조건도 on 절에 들어가야한다.
		만약에 where 절을 쓰면 메인 테이블이 다 나오지 않을 수 있다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<100> 고객번호, 고객명, 고객전화번호, 담당직원명, 담당직원직급, 담당직원연봉등급을 검색하라 ? 
	<조건> 담당직원이 없는 고객도 포함
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select
		c.cus_no	"고객번호"
		,c.cus_name	"고객명"
		,c.tel_num	"고객전화번호"
		,e.emp_name	"담당직원명"
		,e.jikup	"담당직원직급"	
		,s.sal_grade_no	"담당직원연봉등급"
	from
		customer c, employee e, salary_grade s
	where
		c.emp_no = e.emp_no(+) and (e.salary between s.min_salary(+) and s.max_salary(+));
	------------------------------------------------------------
	<주의> employee 입장에서 메인 테이블은 customer 이고, salary_grade 테이블 입장에서 메인 테이블은 employee 이다.
		메인에 딸려나오는 테이블의 컬럼에 (+)를 붙이면 된다.
	------------------------------------------------------------
	<주의> 아래 처럼은 안된다. 즉 (+)를 양쪽에 붙일수는 없다.
		s.min_salary(+)<=e.salary(+) and s.max_salary(+)>=e.salary(+)


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<101> 고객번호, 고객명, 고객주민번호를 검색하라 ? <조건> 단 연봉이 3000 이상인 담당직원이 담당한 고객 이어야한다
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select
		c.cus_no
		c.cus_name
		c.tel_num
	from
		customer c, employee e
	where	
		e.salary>=3000 and e.emp_no=c.emp_no



■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<102> 고객번호, 고객명, 고객주민번호를 검색하라 ? <조건> 40살 이상인 담당직원이 담당한 고객 이어야한다
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select
		c.cus_no
		c.cus_name
		c.tel_num
	from
		customer c, employee e
	where
		c.emp_no = e.emp_no and and 
		(
			extract(year from sysdate)
			-
			extract(year from
					 to_date(
						decode(substr(e.jumin_num,7,1),'1','19','2','19','20')
							 || substr(e.jumin_num,1,6)
						,'YYYYMMDD'
					)
				)+1
			)>=40
	--------------------------------------------------------------
	<주의> 코딩상 분명히 조인이지만 출력되는 컬럼은 한개의 테이블에 나오는 컬럼이다.
		위 코딩은 조인이 출력 목적이 아닌 조건 목적으로 사용된 것이다.
	--------------------------------------------------------------
	10번 부서 또는 30번 부서 직원이 담당하는 고객을 검색하면?
	--------------------------------------------------------------
	select
		c.cus_no
		,c.cus_name
	from
		customer c, employee e
	where
		c.emp_no = e.emp_no and
		e.dep_no in(10,30);


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<103> 고객번호, 고객명, 담당직원번호, 담당직원명, 담당직원 소속부서명, 담당직원 연봉등급,
	담당직원 직속상관명, 담당직원 직속상관직급, 직속상관연봉등급을 검색하라 ?
	<조건> 고객은 다 나와야하고 null은 없음 으로 표시
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	
	select
		c.cus_no				"고객번호"
		,c.cus_name				"고객명"
		,nvl(to_char(e1.emp_no), '없음')	"담당직원번호"
		,nvl(e1.emp_name, '없음')		"담당직원명"
		,nvl(d.dep_name, '없음')		"담당직원소속부서명"
		,nvl(to_char(s1.sal_grade_no), '없음') 	"담당직원연봉등급"
		,nvl(e2.emp_name, '없음')		"담당직원직속상관명"
		,nvl(e2.jikup, '없음')			"담당직원직속상관직급"
		,nvl(to_char(s2.sal_grade_no), '없음')	"직속상관연봉등급"
	from
		customer c, employee e1, dept d, salary_grade s1, employee e2, salary_grade s2
	where
		c.emp_no = e1.emp_no(+)
		and d.dep_no(+) = e1.dep_no
		and e1.mgr_emp_no = e2.emp_no(+)
		and e1.salary between s1.min_salary(+) and s1.max_salary(+)
		and e2.salary between s2.min_salary(+) and s2.max_salary(+)
	order by c.cus_no asc;
	-------------------------------------------------------------
	select
		c.cus_no				"고객번호"
		,c.cus_name				"고객명"
		,nvl(to_char(e1.emp_no), '없음')	"담당직원번호"
		,nvl(e1.emp_name, '없음')		"담당직원명"
		,nvl(d.dep_name, '없음')		"담당직원소속부서명"
		,nvl(to_char(s1.sal_grade_no), '없음') 	"담당직원연봉등급"
		,nvl(e2.emp_name, '없음')		"담당직원직속상관명"
		,nvl(e2.jikup, '없음')			"담당직원직속상관직급"
		,nvl(to_char(s2.sal_grade_no), '없음')	"직속상관연봉등급"
	from
		((((customer c left outer join employee e1 on c.emp_no = e1.emp_no)
		left outer join dept d on e1.dep_no = d.dep_no)
		left outer join salary_grade s1 on e1.salary between s1.min_salary and s1.max_salary)
		left outer join employee e2 on e1.mgr_emp_no = e2.emp_no)
		left outer join salary_grade s2 on e2.salary between s2.min_salary and s2.max_salary
	order by
		c.cus_no asc;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<104> 직원명, 직원전화번호, 고객명, 고객전화번호를 종으로 붙여 검색하라 ? 조건은 중복하지 말것.
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	------------------------------------------
	union
	------------------------------------------
		서로 다른 테이블의 컬럼을 종으로 붙이는 작업을 말한다.
		union 규칙
			=> 컬럼의 개수가 일치해야한다.
			=> 붙는 컬럼의 자료형이 일치해야한다.
	------------------------------------------
	select emp_name||'직원', phone from employee
	union
	select cus_name||'고객', tel_num from customer;	
	------------------------------------------
	union만 쓰면 중복행을 제거한다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<105> 직원명, 직원전화번호, 고객명, 고객전화번호를 종으로 붙여 검색하라 ? 조건은 중복 허락
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select emp_name, phone from employee
	union all
	select cus_name, tel_num from customer;	
	------------------------------------------
	union all을 쓰면 중복행을 허락한다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<106> 기타 함수 정리하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
-------------------------------
숫자함수
-------------------------------	
	-----------------
	abs ( n )
	-----------------
		▶ 숫자 n의 절대값을 반환
	-----------------
	floor ( n )
	-----------------
		▶ 숫자 n이 정수면 그대로 반환하고, 실수면 실수보다 작으면서
			제일 가까운 정수를 반환
		▶ 좌표계에서 쿵 찍어서 왼쪽 정수값
	-----------------
	ceil ( n )
	-----------------
		▶ 숫자 n이 정수면 그대로 반환하고, 실수면 실수보다 크면서
			제일 가까운 정수를 반환
		▶ 죄표계에서 쿵 찍어서 오른쪽 정수값
	-----------------
	round ( n , m )
	-----------------
		▶ 숫자 n에서 소수 m+1 자리에서 반올림한 수 리턴
	-----------------
	trunc ( n , m )
	-----------------
		▶ 숫자 n에서 소수 m+1 자리부터 버림
	-----------------
	sign ( n )
	-----------------
		▶ n > 0 면 1, n < 0 면 -1, n = 0 면 0을 반환
	-----------------
	mod ( n , m )
	-----------------
		▶ n / m 후 나머지 값을 반환
	-----------------
	power( n , m )
	-----------------
		▶ n의 m 승을 반환
-------------------------------
문자함수
-------------------------------	
	-----------------
	chr(n)
	-----------------
		▶ 정수 n을 ascii(아스키) 문자기호로 리턴한다
	-----------------
	uppper(s)
	-----------------
		▶ 문자열 s를 대문자로 변환시켜 리턴한다
	-----------------
	lower(s)
	-----------------
		▶ 문자열 s를 소문자로 변환시켜 리턴한다
	-----------------
	length(s)
	-----------------
		▶ 문자열 s의 길이를 리턴한다
	-----------------
	substr(s, n1, n2)
	-----------------
		▶ 문자열 s에서 n1번째 자리부터 n2개 까지의 문자를 리턴한다
		▶ n2 생략 시 마지막까지 문자를 리턴한다
		▶ n1이 0일 경우, 1로 바꿔 실행된다
		▶ 자리수는 n>0 경우 왼쪽부터, n1<0 경우 오른쪽부터 셈한다
		-----------------------------------
		select substr( 'You are not alone', 9, 3 ) from dual;
		select substr( 'You are not alone', 0, 5 ) from dual;
		select substr( 'You are not alone', 5) from dual;
		select substr( 'You are not alone', -5, 2 ) from dual;
		select substr( 'You are not alone', 5, 0 ) from dual;
	-----------------
	trim(s)
	-----------------
		▶ 문자열 s1의 맨 좌구측으 ㅣ공백을 제거하여 리턴한다
			제거 후 또 있으면 계속 제거 후 리턴한다
	-----------------
	replace( s1, s2, s3 )
	-----------------
		▶문자열 s1에서 s2를 s3로 수정해서 리턴한다.
		▶<예> select replace(addr, '서울특별시','서울시')  from employee
		-----------------------------------------------------
		select replace( 'You are not alone', 'You', 'We' ) from dual;
		select replace( 'You are not alone', 'not' ) from dual;
		-----------------------------------------------------
		select translate( 'You are not alone', 'You', 'We' ) from dual;
						*철자 하나하나씩 대응해서 바꿈
	-----------------
	initcap( s )
	-----------------
		▶문자열 s에서 각 단어의 첫 문자만 대문자로 변환하고 나머지는
		  모두 소문자로 리턴한다.
		▶select  initcap( 'abc def' ) from dual;
	-----------------
	lpad( s1, n, s2 )
	-----------------
		▶n 자리 만큼 확보하고 s1을 오른쪽 정렬 후 왼쪽에 생긴 빈 공백에
		  문자열 s2를 채워 리턴한다.
		▶select lpad( 'abc', 7, ' ' ) from dual;
	-----------------
	rpad( s1, n, s2 )
	-----------------
		▶n 자리 만큼 확보하고 s1을 왼쪽 정렬 후 오른쪽에 생긴 빈 공백에
		  문자열 s2를 채워 리턴한다.
		▶select rpad( 'abc', 7, '#' ) from dual;
	-----------------
	instr( s1, s2, n1, n2 )
	-----------------
		▶( s1:타겟문자, s2:찾을문자, 에서 n1:검색시작위치, n2:몇번째 )
		<주의>오라클에서 위치를 따질 때 시작은 0이 아니라 1이다.
		▶문자열 s1 에서 문자열 s2 가 있는 위치 반환. (자바의 indexOf(~) 와 비슷한 기능)
		select
			instr( 'Every Sha-la-la-la Every wo-o-wo-o', 'la' ),
			instr( 'Every Sha-la-la-la Every wo-o-wo-o', 'la', 1),
			instr( 'Every Sha-la-la-la Every wo-o-wo-o', 'la', 1, 2),
			instr( 'Every Sha-la-la-la Every wo-o-wo-o', 'la', 12, 2)
		from dual;


		select * from employee where emp_name like '%김%'
		select * from employee where instr(emp_name, '김')>0;
		------------------------------------------------------------
		select * from employee where instr(emp_name, '김')=1;
		select * from employee where emp_name like '김%'

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<107> subquery(서브쿼리)가 뭐죠 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	------------------------------------------------------------
	select, insert, update, delete 구문 안에 들어있는 또 다른 select문을 말한다.
	------------------------------------------------------------
	<주의> from 절에 나오는 select는 서브쿼리가 아니라 inline(인라인뷰) 라고 부른다.
	------------------------------------------------------------
	--------------------------------
	서브쿼리 사용 시 주의점
	--------------------------------
		select, update, delete 안의 서브쿼리는 꼭 ( ) 로 묶는다.
		경우에 따라 조인 대신 서브쿼리를 써도 같은 결과를 낼 수 있다. 이때 join보다 서브쿼리의 부하가 더 많이 걸린다.

	--------------------------------
	서브쿼리 종류
	--------------------------------
		------------------------
		비상관쿼리(Noncorrelated Subquery)
		------------------------
			[서브쿼리]와 [외부쿼리]가 연관성이 없다.
			[서브쿼리] 실행 후의 결과값을 가지고 [외부쿼리] 실행된다.
	
			select * from employee where salary >= (select avg(salary) from employee)
		------------------------
		상관쿼리(Correlated Subquery)
		------------------------
			[서브쿼리]와 [외부쿼리]가 연관성이 있다.
			[서브쿼리]와 [외부쿼리]가 서로 통신하면서 쿼리가 진행된다.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<108> 최고 연봉을 받는 직원을 검색하라 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	
	------------------------------------------------------------------------
	select * from employee where salary = (select max(salary) from employee);
	------------------------------------------------------------------------
	서브쿼리 (select max(salary) from employee) 가 먼저 실행되고 난 후 리턴되는
	최고연봉을 가지고 바깥 쿼리가 실행된다.
	위 쿼리는 비상관쿼리이다. [서브쿼리] 실행 후의 결과값을 가지고 [외부쿼리] 실행되기 때문이다.
	<주의> ~ where salary = max(salary); 이케하면 안된다.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<109> 평균 연봉 이상을 받는 직원을 검색하라 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select * from employee where salary >= (select avg(salary) from employee);


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<110> 20번 부서에서 최고 연봉자 직원을 검색하라 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select * from employee where salary = (select max(salary) from employee where dep_no = 20) and dep_no=20;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<111> 10번 부서 직원들이 관리하는 [고객번호], [고객명], [직원번호]를 검색하라 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	--------------------------------------------------------
	조인 답
	--------------------------------------------------------
	select
		cus_no, cus_name, emp_no
	from
		customer c, employee e
	where
		c.emp_no = e.emp_no and e.dep_no=10;
	--------------------------------------------------------
	서브쿼리 비상관쿼리 답
	--------------------------------------------------------
	select
		cus_no, cus_name, emp_no
	from
		customer
	where
		emp_no in(select emp_no from employee where dep_no=10)
	--------------------------------------------------------
		in뒤에 n행 1열의 결과가 나오는 서브쿼리가 나오면
		n행 1열의 검색 데이터가 in 뒤에 콤마(,)로 나열된다.
	--------------------------------------------------------
	서브쿼리 비상관쿼리 답2
	--------------------------------------------------------
	select
		cus_no, cus_name, emp_no
	from
		customer
	where
		emp_no = any(select emp_no from employee where dep_no=10)
	--------------------------------------------------------
	서브쿼리 상관쿼리 답
	--------------------------------------------------------
	select
		c.cus_no, c.cus_name, c.emp_no
	from
		customer c
	where
		(select e.dep_no from employee e where c.emp_no = e.emp_no)=10;
	--------------------------------------------------------
	select
		c.cus_no, c.cus_name, c.emp_no
	from
		customer c
	where
		(select count(*) from employee e where c.emp_no = e.emp_no and e.dep_no=10)>0;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<112> [직원명], [직급], [연봉], [전체연봉에서 차지하는 비율]을 검색하라 ?
	단 [전체연봉에서 차지하는 비율]은 소수점 버림하고 %로 표현하라
	단 높은 비율이 먼저 나오게 정렬하라
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	--------------------------------------------------------
	select
		emp_name	"직원명"
		,jikup		"직급"
		,salary		"연봉"
		,floor(salary/(select sum(salary) from employee)*100) ||'%' "연봉비율"
	from
		employee
	order by
		salary/(select sum(salary) from employee)*100	desc;
	--------------------------------------------------------
	<주의> 정렬할 때는 소수점 컨트롤을 하지 말고 소수점이 널부러지게 하고 정렬해서 정확한 정렬이 된다.
	--------------------------------------------------------


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<113> 평균 연봉 이상이고 최대 연봉 미만의 [직원명], [연봉], [전체평균연봉], [전체최대연봉]을 출력하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select
		emp_name				"직원명"
		,salary					"연봉"
		,(select avg(salary) from employee)	"전체평균연봉"
		,(select max(salary) from employee)	"전체최대연봉"
	from
		employee
	where
		salary<(select max(salary) from employee) 
		and 
		salary >= (select avg(salary) from employee);


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<114> 최고 연봉 직원의 [직원번호], [직원명], [부서명], [연봉]을 검색하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select
		e.emp_no
		,e.emp_name
		,d.dep_name
		,e.salary
	from
		employee e,dept d
	where
		e.dep_no = d.dep_no and e.salary = (select max(salary) from employee);


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<115> 담당 고객이 2명 이상인 [직원번호], [직원명], [직급]을 검색하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select
		emp_no
		,emp_name
		,jikup
	from
		employee e
	where
		(select count(*) from customer c where e.emp_no = c.emp_no)>=2;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<116> [직원번호], [직원명], [소속부서명]을 검색하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	
	---------------------------------------
	조인 답
	---------------------------------------
	select
		e.emp_no
		,e.emp_name
		,d.dep_name
	from
		employee e, dept d
	where
		e.dep_no = d.dep_no;
	---------------------------------------
	서브쿼리 답
	---------------------------------------
	select
		e.emp_no
		,e.emp_name
		,(select d.dep_name from dept d where d.dep_no=e.dep_no)
	from
		employee e;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<117> [직원번호], [직원명], [연봉], [연봉 순위]을 검색하면 ? 단 [연봉순위]를 오름차순 유지
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select
		e1.emp_no						"직원번호"
		,e1.emp_name						"직원명"
		,e1.salary							"연봉"
		,(select count(*)+1 from employee e2 where e2.salary>e1.salary)	"연봉순위"
	from
		employee e1,
	order by 
		4;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<118> [직원번호], [직원명], [담당고객수]를 검색하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select
		e.emp_no						"직원번호"
		,e.emp_name						"직원명"
		,(select count(*) from customer c where c.emp_no = e.emp_no) 	"담당고객수"
	from
		employee e ;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<119> 아래처럼 [부서명], [부서직원수], [부서담당고객수]를 검색하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select
		d.dep_name							"부서명"
		,(select count(*) from employee e where e.dep_no = d.dep_no) || '명'	"직원총수" 
		,(select count(*) from employee e, customer c
			where e.dep_no=d.dep_no and e.emp_no = c.emp_no) || '명'	"담당총고객수"
	from
		dept d
	order by 
		2 desc;

	----------------------------------------------
	e.emp_no = c.emp_no 는 조인 조건
	e.dep_no = d.dep_no 행을 골라내는 조건

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<120> [직원번호], [직원명], [직급], [주민번호], [직급서열순위]를 검색하면 ?
	단 직급이 같으면 나이 많은 직원이 [직급서열순위] 위이다. 그리고 [직급서열순위]를 오름차순 유지
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select
		e1.emp_no			"직원번호"
		,e1.emp_name		"직원명"
		,e1.jikup			"직급"
		,e1.jumin_num		"주민번호"
		,(select count(*)+1 from employee e2
			where
				decode(e2.jikup,'사장','1','부장','2','과장','3','대리','4','주임','5',6)
					< decode(e1.jikup,'사장','1','부장','2','과장','3','대리','4','주임','5',6))
				or
				( e2.jikup = e1.jikup and
				decode( substr(e2.jumin_num,7,1),'1','19','2','19','20') || substr(e2.jumin_num,1,6)	
				<	decode( substr(e1.jumin_num,7,1),'1','19','2','19','20') || substr(e1.jumin_num,1,6)))	"직급서열순위"
	from
		employee e1
	order by
		5;
	---------------------------------------------------------------------------
	select
		e1.emp_no			"직원번호"
		,e1.emp_name		"직원명"
		,e1.jikup			"직급"
		,e1.jumin_num		"주민번호"
		,(select count(*)+1 from employee e2
			where
				decode(e2.jikup,'사장','1','부장','2','과장','3','대리','4','주임','5',6)
					< decode(e1.jikup,'사장','1','부장','2','과장','3','대리','4','주임','5',6)
				or
				( e2.jikup = e1.jikup and
				to_number( case when substr(e2.jumin_num,7,1) in('1','2') then '19' else '20' end || substr(e2.jumin_num,1,6))	
				< to_number( case when substr(e1.jumin_num,7,1) in('1','2') then '19' else '20' end || substr(e1.jumin_num,1,6))))	"직급서열순위"
	from
		employee e1
	order by
		5;          
					--자릿수가 같다면 비교할때 to_number로 안바꿔도 된다
	
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<121> [고객번호], [고객명], [고객전화번호], [담당직원명], [담당직원직급], [부서번호]를 검색하면 ?
	<조건> 담당직원이 없는 고객도 포함
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	----------------------------------------------------------------
	서브쿼리 답
	----------------------------------------------------------------
	select
		c.cus_no			"고객번호"
		,c.cus_name		"고객명"
		,c.tel_num		"고객전화번호"
		,(select e.emp_name from employee e where c.emp_no=e.emp_no)	"담당직원명"
		,(select e.jikup from employee e where c.emp_no=e.emp_no)	"담당직원직급"
		,(select e.dep_no from employee e where c.emp_no=e.emp_no)	"부서번호"
	from
		customer c;
	----------------------------------------------------------------
	조인 답 ( 오라클 조인 )
	----------------------------------------------------------------
	select
		c.cus_no
		,c.cus_name
		,c.tel_num
		,e.emp_name
		,e.jikup
		,d.dep_no
	from
		customer c, employee e, dept d
	where
		c.emp_no = e.emp_no(+) and e.dep_no = d.dep_no(+) ;
	----------------------------------------------------------------
	조인 답 ( ANSI 조인 )
	----------------------------------------------------------------
	select
		c.cus_no
		,c.cus_name
		,c.tel_num
		,e.emp_name
		,e.jikup
		,d.dep_no
	from
		(customer c left outer join employee e on c.emp_no = e.emp_no)
		left outer join dept d on e.dep_no = d.dep_no;
		
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<122> [고객번호], [고객명], [고객전화번호], [담당직원명], [담당직원직급], [부서번호]를 검색하면 ?
	<조건> 고객정보는 모두보이고 직원정보는 10번 부서만 보일것
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	----------------------------------------------------------------
	서브쿼리 답
	----------------------------------------------------------------
	select
		c.cus_no							"고객번호"
		,c.cus_name						"고객명"
		,c.tel_num						"고객전화번호"
		,(select e.emp_name from employee e where c.emp_no=e.emp_no and e.dep_no = 10)"담당직원명"
		,(select e.jikup from employee e where c.emp_no=e.emp_no and e.dep_no = 10)	"담당직원직급"
		,(select e.dep_no from employee e where c.emp_no=e.emp_no and e.dep_no = 10)	"부서번호"
	from
		customer c
	order by 
		1;

	
	----------------------------------------------------------------
	조인 답 ( 오라클 조인 )
	----------------------------------------------------------------
	select
		c.cus_no			"고객번호"
		,c.cus_name		"고객명"
		,c.tel_num		"고객전화번호"
		,e.emp_name		"담당직원명"
		,e.jikup			"담당직원직급"
		,e.dep_no		"부서번호"
	from
		customer c, employee e
	where
		c.emp_no = e.emp_no(+) and e.dep_no(+) = 10
	order by 
		1;
	----------------------------------------------------------------
	조인 답 ( ANSI 조인 )
	----------------------------------------------------------------
	select
		c.cus_no			"고객번호"
		,c.cus_name		"고객명"
		,c.tel_num		"고객전화번호"
		,e.emp_name		"담당직원명"
		,e.jikup			"담당직원직급"
		,e.dep_no		"부서번호"
	from
		customer c left outer join employee e on c.emp_no = e.emp_no and e.dep_no = 10
	order by 
		1;
						-- where절에 쓰는 순간 고객은 전부 나오지 않는다

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<123> GROUP BY 구문이 뭔가요 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	▶ select 절에 있는 컬럼안의 중복 데이터를 [하나로 그룹] 지어주는 역할을 한다.
	
	▶ 주로 그룹을 지어 통계를 낼때 사용한다.
		
	▶ GROUP BY 구문 문법은 간단하나 통계를 내는 과정에서 각종 함수가 때거지로 등장한다.
		그러므로 GROUP BY 구문은 함수와의 싸움이다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<124> 부서별로 [부서번호], [급여합], [평균급여], [인원수]를 출력하면 ? 평균은 소수 2째자리에서 반올림
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select
		dep_no			"부서번호"
		, sum(salary)		"급여합"
		, round(avg(salary),1)	"평균급여"
		, count(*)			"인원수"
	from
		employee
	group by
		dep_no;
	----------------------------------------------------------
	▶ select 절에 일반 컬럼과 그룹함수 컬럼이 등장하면 group by 뒤에는 반드시 그룹지을 일반 컬럼이 나와야한다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<125> 직급별로 [직급], [급여합], [평균급여], [인원수]를 출력하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select
		jikup			"직급"
		, sum(salary)		"급여합"
		, round(avg(salary),1)	"평균급여"
		, count(*)	||'명'		"인원수"
	from
		employee
	group by
		jikup;
	
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<126> 부서별, 직급별, [부서번호], [직급], [급여합], [평균급여], [인원수]를 출력하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select
		dep_no			"부서번호"
		, jikup			"직급"
		, sum(salary)		"급여합"
		, round(avg(salary),1)	"평균급여"
		, count(*)			"인원수"
	from
		employee
	group by
		dep_no, jikup

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<127> 부서별로 직급별, [부서번호], [직급], [급여합], [평균급여], [인원수]를 출력하되 인원수는 3명 이상을 출력하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select
		dep_no			"부서번호"
		, jikup			"직급"
		, sum(salary)		"급여합"
		, round(avg(salary),1)	"평균급여"
		, count(*)			"인원수"
	from
		employee
	group by
		dep_no, jikup
	having
		count(*) >= 3;	
	-----------------------------------------------------
	group by 결과물에서 행을 골라낼 때에는 where를 쓰지 말고 having을 사용한다.
	-----------------------------------------------------
	인라인 뷰를 사용하면 다음과 같이 풀 수 있다.
	-----------------------------------------------------
	select
		*
	from
		(select
			dep_no			DEP_NO
			,jikup			JIKUP
			,sum(salary)		TOT_SALARY
			,round(avg(salary),1)	AVG_SALARY
			,count(*)		EMP_CNT
		from
			employee
		group by
			dep_no, jikup)
	where
		emp_cnt>=3;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<128> 부서별 성별로, [부서번호], [성], [급여합], [평균급여], [인원수]를 출력하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select
		dep_no						"부서번호"
		, decode(substr(jumin_num,7,1),'1','남','3','남','여')	"성"
		, sum(salary)					"급여합"
		, round(avg(salary),1) ||'만원'				"평균급여"
		, count(*)	||'명'					"인원수"
	from
		employee
	group by
		dep_no,decode(substr(jumin_num,7,1),'1','남','3','남','여');

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<129> 입사년도별로 [입사년도], [인원수]를 출력하고 년도별로 오름차순 하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select
		to_char(hire_date,'YYYY')	"입사년도"
		,count(*)			"인원수"
	from
		employee
	group by
		to_char(hire_date,'YYYY') 
	order by
		"입사년도"  asc;    

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<130> 부서별로 [부서번호], [평균근무년수]를 출력하면 ? 근무년수는 소수점 2째 자리에서 반올림할 것
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	
	select
		dep_no						"부서번호"
		,round(avg((sysdate - hire_date)/365),1) || '년 근무'	"평균근무년수"
	from
		employee
	group by
		dep_no;
	
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<131> 입사분기별로 [입사분기], [인원수]를 출력하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select
		to_char(hire_date,'Q')	"입사분기"
		count(*)		"인원수"
	from
		employee
	group by
		to_char(hire_date,'Q');

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<132> 입사연대별, 성별로 [입사연대], [성], [연대별 입사자수] 출력하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select
		substr(to_char(hire_date,'YYYY'),1,3)||'0년대'		"입사연대"
		,decode(substr(jumin_num,7,1),'1','남','3','남','여')		"성"
		,count(*)	"연대별 입사자수"
	from
		employee
	group by
		substr(to_char(hire_date,'YYYY'),1,3)||'0년대', decode(substr(jumin_num,7,1),'1','남','3','남','여');	

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<133> [직원명], [입사일] (년-월-일 ~/4분기 한글 1자리 요일), [퇴직일](년-월-일) 출력하면 ?
	<조건> 퇴직일은 입사 후 20년 5개월 10일 후
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select
		emp_name							"직원명"
		,to_char(hire_date, 'YYYY-MM-DD Q')||'/4 분기'
		,to_char(hire_date,'(DY)','NLS_DATE_LANGUAGE = Korean')			"입사일"
		,to_char(add_months(hire_date, 5+20*12)+10,'YYYY-MM-DD')		"퇴직일"						"퇴직일"
	from
		employee;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<134> 직원들이 있는 부서별로 [부서번호], [부서위치], [직원수]를 출력하면 ? 모든 부서 다 나오게
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select
		d.dep_no			"부서번호"
		,d.loc			"부서위치"
		,count(e.emp_name)	"직원수"
	from
		employee e, dept d
	where
		e.dep_no(+) = d.dep_no
	group by
		d.dep_no, d.loc
	order by
		d.dep_no;
	-----------------------------------------------
	select
		d.dep_no	"부서번호"
		,d.loc	"부서위치"
		,(select count(*) from employee e where e.dep_no=d.dep_no) "직원수"
	from
		dept d
	where
		--(select count(*) from employee e where e.dep_no=d.dep_no)>0;	
	
	*아래꺼 0명으로 부서 검색이 됨(where절 빼면)



■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<135> 월별로 [입사월], [인원수]를 출력하면 ?
	<조건> 입사월 오름차순 유지
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select
		to_char(hire_date,'MM')	"입사월"
		,count(*)			"인원수"
	from
		employee
	group by
		to_char(hire_date,'MM')
	order by
		"입사월";
	-----------------------------------------------------
	위 문제는 없는 달은 나오지 않는다. 없는 달도 포함하여, 즉 1월~12월까지 다 나오게 하려면 ?
	-----------------------------------------------------
	select
		m.month||'월'	"입사월"
		,count(e.emp_name) "입사인원수"
	from
		(
			select '01' "MONTH" from dual union
			select '02' from dual union select '03' from dual union select '04' from dual union
			select '05' from dual union select '06' from dual union select '07' from dual union
			select '08' from dual union select '09' from dual union select '10' from dual union	
			select '11' from dual union select '12' from dual
		) m
		, employee e
	where
		to_char(e.hire_date(+),'MM') = m.month
	group by
		m.month||'월'
	order by
		"입사월";
	-----------------------------------------------------
	상관쿼리 사용
	-----------------------------------------------------
	select
		m.month||'월'									"입사월"
		,(select count(*) from employee e where to_char(e.hire_date,'MM')=m.month	"입사인원수"
	from
		(
			select '01' "MONTH" from dual union
			select '02' from dual union select '03' from dual union select '04' from dual union
			select '05' from dual union select '06' from dual union select '07' from dual union
			select '08' from dual union select '09' from dual union select '10' from dual union	
			select '11' from dual union select '12' from dual
		) m
	



■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<136> employee 테이블에서 직급순서대로 정렬하여 직급별로 [직급], [직급평균연봉], [인원수]를 출력하면 ?
	(높은 직급이 먼저 나와야함.)
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■	

	select
		jikup
		,avg(salary)
		,count(*)
	from
		employee
	group by
		jikup;
	order by
		decode(jikup,'사장','1','부장','2','과장','3','대리','4','사원','5','6') asc;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<137> 부서별 [부서번호], [부서명], [직원수], [관리고객수]를 출력하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	--------------------------------------------------
	답1
	--------------------------------------------------
	select
		d.dep_no			"부서번호"
		,d.dep_name			"부서명"
		,count(distinct e.emp_no)	"직원수"
		,count(c.emp_no)		"관리고객수"
	from
		employee e, dept d, customer c
	where	
		e.dep_no(+) = d.dep_no and c.emp_no(+) = e.emp_no 
	group by
		d.dep_no, d.dep_name;
	--------------------------------------------------
	count(distinct e.emp_no) 를 count(e.emp_no) 하면안됨
	distinct를 안쓰면 직원수가 중복되어서 나온다
	--------------------------------------------------
	count(c.emp_no) 를 count(distinct c.emp_no) 하면안됨
	distinct 쓰면 고객을 담당하는 직원수가 된다.

	--------------------------------------------------
	답2
	--------------------------------------------------
	select
		d.dep_no	"부서번호"
		,d.dep_name	"부서명"
		,(select count(*) || '명' from employee e where e.dep_no=d.dep_no)	"부서직원수"
		,(select count(*) || '명' from employee e, customer c where e.dep_no=d.dep_no and e.emp_no=c.emp_no)	"담당고객수"
	from
		dept d;




	
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<138> 퇴직일이 60세라는 기준 하에 아래처럼 출력하면 ?
	[직원번호], [직원명], [근무년차], [퇴직일까지 남은 년도], [생일(-년-월-일 요일명)], 
	[소속부서명], [직속상관명], [직속상관 부서명]
	단 모든 직원 다 나오고, 직급 높은 사람 먼저 나오고 직급이 같으면 나이가 많은 사람이 나와야함.
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■


select 
	e1.emp_no                                                                                "[직원번호]"
	, e1.emp_name                                                                            "[직원명]"
	, ceil((sysdate-e1.hire_date)/365)                                                       "[근무년차]"
	, to_number(to_char(sysdate,'yyyy'))-to_number((case substr(e1.jumin_num,7,1) 
		when '1' then '19' when '2' then '19'else '20'end)||substr(e1.jumin_num,1,2))+1  "[나이]"
	, 60-(to_number(to_char(sysdate,'yyyy'))-to_number((case substr(e1.jumin_num,7,1) 
		when '1' then '19' when '2' then '19'else '20'end)||substr(e1.jumin_num,1,2))+1) "[퇴직년도까지]"
	, to_char(to_date(case substr(e1.jumin_num,7,1) 
		when '1' then '19' when '2' then '19' else '20' end
			||substr(e1.jumin_num,1,6),'yyyymmdd'),'yyyy-mm-dd')||' '	
			||to_char(to_date(case substr(e1.jumin_num,7,1) 
				when '1' then '19' when '2' then '19' else '20' end
			||substr(e1.jumin_num,1,6),'yyyymmdd'),'dy','nls_date_language = korean') "[생일]"
	, e1.jikup                                                                                "[직급]"
	, d1.dep_name                                                                             "[소속부서명]"
    , e2.emp_name                                                                             "[직속상관명]"
    , d2.dep_name                                                                             "[직속상관소속부서명]"
from 
    employee e1, dept d1,employee e2, dept d2
where 
    e1.dep_no  = d1.dep_no(+) and e1.mgr_emp_no = e2.emp_no(+) and e2.dep_no = d2.dep_no(+)
order by 
    decode(e1.jikup ,'사장',1 ,'부장',2 ,'과장',3 ,'대리',4 ,5)
    , case substr(e1.jumin_num,7,1)  when '1' then '19' when '2' then '19' else '20' end ||substr(e1.jumin_num,1,6)
----------------------------------------------------------------------------------------------------------------
select 
    e1.emp_no "[직원번호]"
    ,e1.emp_name "[직원명]"
    ,ceil((sysdate-e1.hire_date)/365)||'년' "[근무년차]"
    ,to_number(to_char(sysdate,'yyyy'))-to_number((case substr(e1.jumin_num,7,1) 
        when '1' then '19' when '2' then '19'else '20'end)||substr(e1.jumin_num,1,2))+1||'살' "[나이]"
    ,60-(to_number(to_char(sysdate,'yyyy'))-to_number((case substr(e1.jumin_num,7,1) 
        when '1' then '19' when '2' then '19'else '20'end)||substr(e1.jumin_num,1,2))+1)||'년' "[남은 퇴직년도]"
    ,to_char(to_date(case substr(e1.jumin_num,7,1) 
            when '1' then '19' when '2' then '19'else '20'end
                ||substr(e1.jumin_num,1,6),'yyyymmdd'),'yyyy-mm-dd')||' '                
                ||to_char(to_date(case substr(e1.jumin_num,7,1) 
                        when '1' then '19' when '2' then '19'else '20'end
                ||substr(e1.jumin_num,1,6),'yyyymmdd'),'dy','nls_date_language = korean') "생일"
    ,e1.jikup    "[직급]"
    ,(select d.dep_name from dept d where d.dep_no=e1.dep_no) "[소속부서명]"
    ,nvl((select e2.emp_name from employee e2 where e1.mgr_emp_no=e2.emp_no),'없음')   "[직속상관명]"
    ,nvl((select d.dep_name from employee e2, dept d 
            where d.dep_no=e2.dep_no and e1.mgr_emp_no=e2.emp_no)||'','없음')    "[직속상관부서명]"
    ,(select nvl(count(*), 0) from customer c  where c.emp_no=e1.emp_no) "[담당고객수]"
from employee e1
order by 
    decode(e1.jikup ,'사장',1 ,'부장',2 ,'과장',3 ,'대리',4 ,5)
    , case substr(e1.jumin_num,7,1)  when '1' then '19' when '2' then '19' else '20' end ||substr(e1.jumin_num,1,6)

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<139> [인라인뷰(=inline view)] 가 뭔가요 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	from절 뒤에 나오는 select를 말한다.
	from절에는 테이블명이 나온다.
	이자리에 select 나올 경우 select 결과물을 테이블로 생각하면 된다.
	인라인뷰는 select 결과물을 테이블로 취급하기 때문에 메모리에 부담을 준다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<140> 연봉 서열대로 직원을 검색하되 1행 부터 10행 까지만 검색하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	--------------------------------------------------------
	답1
	--------------------------------------------------------
	select
		*
	from
		(select rownum RNUM, e.* from (select * from employee order by salary desc) e
		where rownum <=10)
	where
		RNUM>=1;
	--------------------------------------------------------
	답2	답1보다 속도가 2~3배 느리다.
	--------------------------------------------------------
	select
		*
	from
		(select rownum RNUM, e.* from (select * from employee order by salary desc) e
	where
		RNUM>=1 and RNUM<=10;
	

	--------------------------------------------------------
	오라클은 모든 select 결과물에 rownum 컬럼을 붙여준다.
		이 컬럼안에는 1부터 시작하는 일련번호가 들어가 있다.
	--------------------------------------------------------
	rownum을 order by와 같이 사용시 일련번호가 뒤엉킨다.
		일련번호를 지정후에 order by를 하므로..
	--------------------------------------------------------
	rownum 컬럼이 where 절에 들어갈 때 주의사항
		rownum 자리에 1이 들어가서 false 가 나오는 조건이 있다면 조건이 성립되지 않는다.
	<예> rownum<=3 ( o )	rownum=1 ( o )	rownum>=3 ( x )
	--------------------------------------------------------
	인라인 뷰, 즉 from 절에 나오는 select 는 바깥쪽 select 입장에서는 테이블 처럼 생각한다.
	인라인뷰 안에 rownum 컬럼이 있다면 바깥쪽 select 입장에서안쪽 rownum 컬럼은 단순한 일반 컬럼이 된다.
	--------------------------------------------------------
	<참고> 이렇게 n행 ~m행 까지 검색하는 이유는?
	--------------------------------------------------------
		실제로는 select의 결과물이 웹브라우저로 출력된다.
		만약 select 결과물이 100,000행이면 다 보여줄 경우 웹브라우저 로딩이 걸린다.
		그러므로 1~10행 또는 1행~15행 씩 끊어서 웹브라우저로 출력되야 로딩이 걸리지 않는다.
		이렇게 select 결과물에서 n행 씩 끊어서 화면에 보여주는 것은 [페이징]처리라고 한다.
		
	********************************************************
	<패턴> n행 ~m행 까지 검색하는 select 패턴 정리1
	********************************************************
	select	* from ( select rownum RNUM, zxcvb.* from (
		원하는 정렬 select 문
	) zxcvb where rownum<=마지막 행번호) where RNUM >= 시작행번호;
	
	********************************************************
	<패턴> n행 ~m행 까지 검색하는 select 패턴 정리2 *속도가 느림
	********************************************************
	select	* from ( select rownum RNUM, zxcvb.* from (
		원하는 정렬 select 문
	) zxcvb where RNUM >= 시작행번호 and RNUM<=마지막행번호;

	********************************************************
	<새끼문제> 직원 직급 서열중 2행~ 5행까지 검색하면 ?
	********************************************************
	select * from ( select rownum RNUM, e.* from (
		select * from employee
		order by
			decode(jikup,'사장','1','부장','2','과장','3','대리','4','주임','5','6') asc
	) e where rownum<=5 ) where RNUM>=2;
	
	********************************************************
	<새끼문제> 고객나이 서열중 6행~ 10행까지 검색하면 ?
	********************************************************
	select * from ( select rownum RNUM, c.* from (
	
		select * from customer
		order by
			decode(substr(jumin_num,7,1),'1','19','2','19','20')||substr(jumin_num,1,6) asc
	) c where rownum<=10 ) where RNUM>=6;



■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<141> 오늘부터 10일 이후 까지 날짜 중에 토요일, 일요일, 월요일을 제외한 날의 개수를 구하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select	
		count(*)
	from
		(
			select sysdate "XDAY" from dual
		union select sysdatd+1 from dual union select sysdatd+2 from dual
		union select sysdatd+3 from dual union select sysdatd+4 from dual
		union select sysdatd+5 from dual union select sysdatd+6 from dual
		union select sysdatd+7 from dual union select sysdatd+8 from dual
		union select sysdatd+9 from dual union select sysdatd+10 from dual
		) d
	where
		to_char (d.xday, 'dy', 'nls_datd_language = korean' )!='토'
		and to_char (d.xday, 'dy', 'nls_datd_language = korean' )!='일'
		and to_char (d.xday, 'dy', 'nls_datd_language = korean' )!='월';
	

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<142> 이번달 중에 토요일, 일요일을 제외한 날의 개수를 구하면 ? = 이번달 평일 수 구하기
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select
		count(*)
	from
		(
			select to_date(to_char(sysdate,'YYYY-MM'')||'01-','YYYY-MM-DD')+RNUM-1 "XDAY"
			from (select rownum RNUM from employee union select rownum+20 from employee)
			where RNUM<=to_number(to_char(last_day(sysdate),'dd')
			)
		)d
	where
		to_char(d.xday,'dy', 'nls_datd_language = korean')!='토'
		and to_char(d.xday,'dy', 'nls_datd_language = korean')!='일'
		and XDAY <= last_day(sysdate);
	--------------------------------------------------------------------------------
	select to_date(to_char(sysdate, 'YYYYMM')||'01','YYYYMMDD') from dual -- 이번달 1일 이렇게 31개 하는게 정석임.
	union select to_date(to_char(sysdate, 'YYYYMM')||'01','YYYYMMDD')+1 from dual
	union select to_date(to_char(sysdate, 'YYYYMM')||'01','YYYYMMDD')+2 from dual



■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<143> VIEW(뷰) 가 뭔가요 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	● 실시간으로 select 결과물을 테이블 처럼 가장해서 보여주는 [테이블]이다. [가상 테이블]이라고도 한다.
	
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<144> VIEW(뷰) 특징은 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	● 객체로써 저장된다. 즉 이름을 가지고 저장된다.
	
	● 뷰도 테이블이므로 select의 대상이 된다.

	● 뷰의 근원이 되는 실존 테이블의 데이터가 변경된 후 뷰가 실행되면 뷰에 그대로 반영된다.
			 (=실존 테이블과 view는 항상 동기화 한다.)

	● 뷰를 가지고 또 다른 뷰를 만들 수 있다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<145> VIEW(뷰) 를 사용하는 목적은 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	-----------------------------------
	<1> [보안성] 때문이다.
	-----------------------------------
		예를 들어 abc 계정이 employee 테이블에 salary만 빼고 다 보게 하려면
		salary만 뺀 select 구문을 employee_vw 라는 이름의view로 만들어 저장하고 
		employee_vw에 select 권한을 주고, employee 테이블에는 select 권한을 주지 않으면
		abc 계정이 employee 테이블에서 salary만 빼고 다 보게 할 수 있다.
	-----------------------------------
	<2> join 등과 같은 길고 복잡한 select 문장을 뷰로 만들어서 테이블 처럼 사용하여 [편의성]을 제공한다.
 	-----------------------------------
		






■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<146> employee 테이블로부터 salary 컬럼만 제외하고 볼 수 있는 뷰 employee_vw1를 생성하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	create view employee_vw1 as
		select 
			emp_no, emp_name, dep_no, jikup, hire_date, jumin_num, phone, mgr_emp_no
		from
			employee;
	---------------------------------------------------------------------
	select * from employee_vw1;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<147> 부서별, 직급별로 [부서번호], [부서명], [직급], [평균연봉]을 출력하는 뷰 employee_vw3을 생성하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	create view employee_vw3 as
	select 
		d.dep_no		"부서번호"
		,d.dep_name	"부서명"
		,e.jikup		"직급"
		,avg(e.salary)	"평균연봉"
	from
		employee e, dept d
	where
		e.dep_no = d.dep_no
	group by
		d.dep_no,d.dep_name, e.jikup
	order by 
		"부서번호", "평균연봉" desc;

		--> <주의> avg(salary) "avg_salary" 에서 별칭을 생략하면 안된다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<148> employee_vw1 에 데이터 , '이승엽', 40, '과장', '1990-09-01', '7811231452719', '01090056376', 1 을 입력하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	-------------------------------------------------------------------------------
	뷰에 insert를 하면 뷰의 근원이 되는 원본 테이블에 insert 된다.
	무조건 insert 되는 것은 아니고 원본 테이블에 insert 되는 상황이어야 한다.
	-------------------------------------------------------------------------------
	insert into employee_vw1 (
		emp_no, emp_name, dep_no, jikup, hire_date, jumin_num, phone, mgr_emp_no
	) values (
		(select nvl(max(emp_no),0)+1 from employee_vw1) --emp_no 구하는 서브쿼리
		, '이승엽', 40, '과장', to_date('1990-09-01','YYYY-MM-DD'), '7811231452719', '01090056376', 1);
	-------------------------------------------------------------------------------
	비록 뷰 employee_vw1 에 insert를 했지만 실제로는 employee 테이블에 입력된 것이다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<149> employee_vw1 에서 주민번호 '7811231452719', 직원명 '이승엽' 의 직급을 부장으로 수정하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	-------------------------------------------------------------------------------
	뷰에 update를 하면 뷰의 근원이 되는 원본 테이블에 update 된다.
	무조건 update 되는 것은 아니고 원본 테이블에 update 되는 상황이어야 한다.
	-------------------------------------------------------------------------------
	update 테이블명 set 컬럼명 = 수정데이터, ~ where 조건식 
	-------------------------------------------------------------------------------
	update employee_vw1 set jikup = '부장' where emp_name = '이승엽' and jumin_num = '7811231452719';
	
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<150> employee_vw1 에서 주민번호 '7811231452719' 인 직원을 제거하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	-------------------------------------------------------------------------------
	뷰에 delete를 하면 뷰의 근원이 되는 원본 테이블에 delete 된다.
	무조건 delete 되는 것은 아니고 원본 테이블에 delete 되는 상황이어야 한다.
	-------------------------------------------------------------------------------
	delete from 테이블명 where 조건식
	-------------------------------------------------------------------------------
	delete from employee_vw1 where jumin_num = '7811231452719';

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<151> 뷰 employee_vw1를 제거하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	drop view employee_vw1;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<152> 다음 뷰에 대한 질문에 대답하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	create view employee_vw4 as
	select emp_no, emp_name, dep_no from employee;
	-------------------------------------------------------------------------------
	<문> 위의 뷰를 만든 후 insert into employee_vw4 values(21, '사오순', 40); 실행하면 성공할까 ?
	-------------------------------------------------------------------------------
	▶ 실패한다. 뷰 employee_vw4 에 입력되는 데이터는 employee 테이블에 입력되는 것과 같다.
		employee 테이블에서 not null, unique 등의 제약조건에 위반되기 때문에 못들어 간다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<153> 다음 뷰에 대한 질문에 대답하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	
	-------------------------------------------------------------------------------
	insert into dept values (60, '전략부', '부산'); 을 실행 한 후 아래뷰 생성 코드를 실행
	-------------------------------------------------------------------------------
	create view dept_vw1 as
		select dep_no, dep_name, loc from dept
		where dep_no=60 with check option;
	-------------------------------------------------------------------------------
	<문> update dept_vw1 set dep_no=70 where dep_no=60; 을 실행하면?
	-------------------------------------------------------------------------------
		▶ 실패. WITH CHECK OPTION이 있으면 where 조건에 위배되는 입력, 수정은 불가능 하다.
		▶ 즉 dept_vw1 란 이름의 view의 모적은 60번 부서를 검색하는 게 목적이므로 이 목적 위배하는 행위는 하지마라
			위배하면 60번 부서를 검색하지 못하게 되니까 위배하지 마라의 의미가 있다.
	-------------------------------------------------------------------------------
	<문> insert into dept_vw1 values(70, '미래부', '대구'); 을 실행하면?
	-------------------------------------------------------------------------------
		▶ 실패.
	
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<154> 다음 뷰에 대한 질문에 대답하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	
	-------------------------------------------------------------------------------
	create view employee_vw6 as
		select emp_no, emp_name, dep_no, jikup, salary from employee where salary>=3000
	with check option;
	-------------------------------------------------------------------------------
		-------------------------------------------------------------------------------
		<문> update employee_vw6 set salary=salary*0.95 where salary>=3000을 실행하면??
		-------------------------------------------------------------------------------
		▶ 실패. WITH CHECK OPTION 이 있으면 where 조건에 위배되는 입력, 수정이 발생할 경우에만 불가능하다.
		▶ 현재 5% 인하해서 3000 밑으로 내려가는 직원이 있으므로 이번 update는 실패한다.
		▶ 만약 5% 인하해서 3000 밑으로 내려가는 직원이 없다면 이 update는 성공할 것이다.
		-------------------------------------------------------------------------------
		<문> update employee_vw6 set salary=salary*1.95 where salary>=3000을 실행하면?
		-------------------------------------------------------------------------------
		▶ 성공. 업데이트로 3000 미만으로 내려가지 않아 조건에 위배되지 않으므로 성공한다.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<155> 다음 뷰에 대한 질문에 대답하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	-------------------------------------------------------------------------------
	create view employee_vw7 as
	select emp_no, emp_name, dep_no, jikup, salary from employee where salary>=3000 WITH CHECK OPTION;
	-------------------------------------------------------------------------------
		-------------------------------------------------------------------------------
		<문> update employee_vw7 set salary=salary*0.95 where salary>=3100; 을 실행하면?
		-------------------------------------------------------------------------------
		▶ 성공. WITH CHECK OPTION이 있으면 where 조건에 위배되는 입력, 수정이 발생할 경우에만 불가능하다.
		▶ 현재 5% 인하해서 3100 밑으로 내려가는 직원이 없으므로 이번 update는 성공한다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<156> 뷰를 만드는 SQL 문법 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	-------------------------------------------------------------------------------
	CREATE [OR REPLACE]	[FORCE | NOFORCE] VIEW 뷰이름 AS select 문장 [WITH READ ONLY] [WITH CHECK OPTION];
	-------------------------------------------------------------------------------
		▶ OR REPLACE
			▷ 동일한 뷰가 있으면 덮어쓴다. 즉 기존의 뷰가 갱신된다. 미사용 시 뷰 생성 불가능.
		▶ FORCE
			▷ 존재하지 않는 테이블로부터 뷰를 만들 경우라도 뷰를 만든다.
			▷ FORCE 에 의해 생성된 뷰를 select로 검색하면 에러가 발생한다. 즉 이름만 존재하고 검색이 불가능한 뷰가 된다.
			▷ 뷰 생성 시 거론한 존재하지 않는 테이블을 나중에 만들고 나면 뷰도 select로 검색이 가능하다.
		▶ NOFORCE
			▷ 존재하지 않는 테이블에서 뷰를 만들 경우 뷰를 만들지 못한다.
			▷ FORCE, NOFORCE 모두 생략 시 NOFORCE 설정과 같다.
		▶ WITH READ ONLY
			▷ 뷰에 대해 입력, 수정, 삭제 작업이 불가능하다.
			▷ 생략 시 특정 조건하에 하나의 테이블에서 만들어진 뷰에 대해서는 입력, 수정, 삭제 작업을 할 수 있고
				실존 테이블에 입력, 수정, 삭제가 된다.
		▶ WITH CHECK OPTION
			▷ 뷰의 WHERE 구문 조건에 위배되는 방향으로 INSERT, UPDATE 작업은 불가능 하다.
			▷ <예> 뷰에 shere salary>=6000 이 있을 경우 salary>=6000 조건에 위배되는 방향으로 입력 수정이 불가능하다.
				예를 들어 salary>=6000 조건에 해당하는 행의 salary를 6000 미만으로 입력, 수정하는 행위는 불가능 하다.
		▶ 생성한 뷰의 정보 검색 방법
			▷ select view_name, text from user_views ;
		▶ select 문에서 실존 테이블에 존재하지 않는 컬럼은 반드시 별칭을 써야한다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<157> employee 테이블에 '장보고', 40, '대리', 3500, '2012-05-28', '8311091109310', '01092499215', 3 데이터를 입력하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	----------------------------------------------------------------------------------
	시퀀스를 사용하여 PK 값을 입력 예
	----------------------------------------------------------------------------------
	insert into employee( 
	    emp_no, emp_name, dep_no, jikup, salary, hire_date, jumin_num, phone_num, mgr_emp_no 
	)
	values( 
	    emp_sq.nextval, '장보고', 40, '대리', 3500, to_date('2012-05-28','YYYY-MM-DD'), '8311091109310', '01092499215', 3 
	);
	----------------------------------------------------------------------------------
	서브쿼리를 사용하여 PK 값을 입력 예
	----------------------------------------------------------------------------------
	insert into employee( 
	    emp_no, emp_name, dep_no, jikup, salary, hire_date, jumin_num, phone_num, mgr_emp_no 
	)
	values( 
	    (select nvl(max(emp_no),0)+1 from employee), 
		'장보고', 40, '대리', 3500, to_date('2012-05-28','YYYY-MM-DD'), '8311091109310', '01092499215', 3 
	);
	----------------------------------------------------------------------------------
	select * from employee;	--> insert 확인
	commit;			--> insert 작업 인정. insert 작업 취소 시 rollback; 실행

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<158> employee 테이블에 직원번호가 18번이고 주민번호 8203121977315, 이름 강감찬 직원의 직급을 주임으로 수정하려면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	----------------------------------------------------------------------------------
	주민번호로 찾아서 수정한 경우 (좋은 답은 아니다. 왜? 주민번호는 DBA가 준 값이 아니므로 신뢰도가 떨어진다.)
	----------------------------------------------------------------------------------
	update 
		employee 
	set 
		jikup = '주임' 
	where 
		jumin_num = '8203121977315'
	----------------------------------------------------------------------------------
	PK로 찾아서 수정한 경우 (좋은 답이다. 왜? PK는 DBA가 준 값이므로 신뢰도가 높다.)
	----------------------------------------------------------------------------------
	update 
		employee 
	set 
		jikup = '주임' 
	where 
		 emp_no=18;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<159>  여성 직원의 월급을 500만원 인상하는 update 문은 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	----------------------------------------------------------------------------------
	update
		employee
	set
		salary = salary + 500
	where
		substr(jumin_num,7,1) in('2','4')
	----------------------------------------------------------------------------------
	update
		employee
	set
		salary = salary + 500
	where
		substr(jumin_num,7,1) any ('2','4')
	----------------------------------------------------------------------------------
	update
		employee
	set
		salary = salary + 500
	where
		jumin_num like '______2%' or jumin_num like '______4%'
	----------------------------------------------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<160> employee 테이블에서 평균 연봉 이상의 직원 연봉을 2% 삭감하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	update
		employee
	set
		salary = salary*0.98
	where
		salary >= (select avg(salary) from employee)


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<161> employee 테이블에서 평균 연봉 보다 적은 연봉자의 연봉을 50만원 인상하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	update
		employee
	set
		salary = salary + 50
	where
		salary < (select avg(salary) from employee)

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<162> 담당 고객이 있는 직원의 급여를 5% 인상하면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	update
		employee
	set
		salary = salary*1.05
	where
		emp_no in ( select emp_no from customer where emp_no is not null ) ;	
	----------------------------------------------------------------------------------
	update
		employee
	set
		salary = salary*1.05
	where
		emp_no = any ( select emp_no from customer where emp_no is not null ) ;	

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<163> 연봉 서열 2~5위까지 5명의 연봉을 10% 인하하면 ?
	정렬기준 >연봉 높은 순서> 직급 높은 순서> 입사일 빠른 순서> 나이 높은 순서
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	update
		employee
	set
		salary = salary * 0.9
	where
		emp_no in
		(select
			emp_no
		from
			(select rownum RNUM, e.* from (
			select emp_no from employee order by salary desc
			, decode(jikup, '사장','1','부장','2','과장','3','대리','4','주임','5','6') asc
			, hire_date asc
			, decode(substr(jumin_num,7,1),'1','19','2','19','20')||substr(jumin_num,1,6) asc
		) e
			where rownum <=5)
		where
			RNUM>=2);

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<164> employee와 똑같은 구조와 똑같은 데이터를 가진 쌍둥이 테이블 employee2 만들면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	
	----------------------------------------------------------------------------------
	create table employee2 as select * from employee;
	----------------------------------------------------------------------------------
	위 SQL 구문은 select 결과물을 실존 테이블로 만드는 SQL 구문이다.
	위 구문으로 테이블을 복사하면 데이터, 자료형, 자료형 크기, not null 제약 조건만 그대로 복사된다.
	<주의> not null 제약 조건 이외의 제약 조건은 따라오지 않는다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<165> employee와 똑같은 구조를 가진 쌍둥이 테이블 employee3 만들되 데이터는 복사해 오지 않으려면 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	
	----------------------------------------------------------------------------------
	create table employee3 as select * from employee where 1=2;
	----------------------------------------------------------------------------------	
	where 조건절에 계속 false가 되는 조건을 걸면 자료형, 자료형 크기, not null 제약 조건만 그대로 복사되고
	데이터는 복사되지 않는다.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<166> 게시판에 입력되는 데이터를 저장하려면 테이블 구조는 어떻게 설계해야 할까 ?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	create table board(
		b_no	number(9)				--> 게시판 글 고유번호
		
		,subject 	varchar2(50)	not null	--> 글 제목
		,writer		varchar2(30)	not null	--> 글쓴이 이름
		,content	varchar2(2000)	not null	--> 글 내용
		,pwd		varchar2(12)	not null	--> 암호
		,email		varchar2(30)	not null	--> 이메일
				
		,reg_date	date	default sysdate		--> 등록일
		,readcount	number(5)	default 0	--> 조회수
		
		,group_no	number(9)	not null	--> 게시판 글의 소속 그룹번호.
		,print_no	number(9)	not null	--> 같은 그룹번호 내에서 화면 출력 순서 번호.
	
		,print_level	number(9)	not null	--> 같은 그룹번호 내에서 들여쓰기 레벨 단계 번호
		
		,primary key(b_no)
		);
	-------------------------------------
	● 정렬에 관련된 컬럼은?
	-------------------------------------
		group_no, print_no
		------------------------
		정렬시 먼저 그룹번호를 내림차순으로 정렬하고 같은 그룹번호
		내에서 화면 출력 순서를 오름차순으로 정렬할 것이다.
	-------------------------------------
	● 부모자식 관계를 표현하는데 사용되는 데이터가 있는 컬럼은? 
	-------------------------------------
		print_level
		------------------------
		자식은 부모보다 1단계 오른쪽으로 밀려 들어가게 만든다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<167> 게시판이 오픈 된 후 처음으로 누군가 아래처럼 글을 올렸다. insert 구문을 쓰면 ?
	
	글제목 => 11월 모두 취업합시다
	글내용 => 어쩌구 저쩌구
	글쓴이 => 희원
	이메일 => hwon@naver.com
	비밀번호 => 1234
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	insert into board(
		b_no
		,subject
		,writer
		,content
		,pwd
		,reg_date
		,readcount
		,group_no
		,print_no
		,print_level
	) values(
		(select nvl(max(b_no),0)+1 from board)
		,'11월 모두 취업합시다'
		,'희원'
		,'어쩌구 저쩌구'
		,'1234'
		,'hwon@naver.com'
		,(select nvl(max(b_no),0)+1 from board)
		,0
		,0
		)
	);

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<168> 누군가 게시판 번호 1번에 아래처럼 댓글을 올렸다. 이때 댓글 올리는 과정 중에 발생되는 SQL 모두 써라 ?
	
	글제목 => 맞습니다. 열공합시다.
	글내용 => 어쩌구 저쩌구
	글쓴이 => 영민
	이메일 => min@naver.com
	비밀번호 => 2345
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	----------------------------------------------------------------------------------
	update board set readcount = readcount+1 where b_no=1;
	----------------------------------------------------------------------------------
	update board set print_no = print_no+1
	where group_no=(select group_no from board where b_no=1)	--> b_no가 1번인 글의 그룹번호
		and
		print_no>(select print_no from board where b_no=1);	--> b_no가 1번인 글의 출력 순서번호
	----------------------------------------------------------------------------------
	insert into board(
		b_no
		,subject
		,writer
		,content
		,pwd
		,email
		,group_no
		,print_no
		,print_level
	) values(
		(select nvl(max(b_no),0)+1 from board)
		,'맞습니다. 열공합시다.'
		,'영민'
		,'어쩌구 저쩌구'
		,'2345'
		,'min@naver.com'
		,(select group_no from board where b_no=1)		--> b_no가 1번인 글의 그룹번호
		,(select print_no+1 from board where b_no=1)		--> b_no가 1번인 글의 출력순서번호에 1더한것
		,(select print_level+1 from board where b_no=1)		--> b_no가 1번인 글의 들여쓰기번호에 1더한것
		)
	);


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<169> 게시판의 모든 글을 출력하면 ?
	출력되는 데이터는 단순역순번호, 제목, 글쓴이, 작성일(년-월-일), 조회수 이다.
	-------------------------------------
	정렬 기준
	-------------------------------------
		그룹번호 내림차순
		출력순서번호 오름차순
	-------------------------------------
	들여쓰기는 print_level 컬럼안의 데이터를 가지고 들여쓰기를 표현하시오
	-------------------------------------
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
		
	select
		x.cnt-rownum+1 "번호", b.*
	from
		(select
			LPAD( ' ', print_level*5, ' ')||decode(print_no,0,'','ㄴ')||subject	"글제목"
			, writer								"글쓴이명"
			, to_char(reg_date,'YYYY-MM-DD')					"등록일"
			, readcount								"조회수"
		from
			board
		order by
			group_no desc, print_no asc
		)b, (select count(*) CNT from board) x

