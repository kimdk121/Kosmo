// ----------------------------------------------------------------
// 프로젝트명 /node_modules/react 안에 default 가 붙어 수출하는 놈을 수입해서
// 현재 파일 안에서 React 란 이름으로 사용한다.
// 프로젝트명 /node_modules/react 안에 default 가 안붙어 수출하는 놈 useState 함수를 수입해서
// 현재 파일 안에서 useState 란 이름으로 사용할 것이다.
// ----------------------------------------------------------------
// <참고> 아래 수입 코드는 클래스 컴포넌트가 선언되는 js 파일안에서는 필수로 수입되는 것들이다.
import React, {useRef, useState } from "react";

// ----------------------------------------------------------------
// 리액트의 단위 프로그램중 하나인 [함수 컴포넌트] 선언하기
// ----------------------------------------------------------------
const RegData = () => {
    // ----------------------------------------------------------------
    // 지역변수 nameRef 선언하고
    // useRef 함수를 호출하여 리턴된 데이터를 저장하기
    // 이후 부터 ref={nameRef} 가진 태그는
    // nameRef.current.focus(); 코딩이 실행되면
    // 포커스가 그 태그 안으로 들어간다.
    // ----------------------------------------------------------------
    const nameRef = useRef(null);
    // ----------------------------------------------------------------
    // 지역변수 names, setNames 선언하고
    // 지역변수 names 에는 [~] 즉 Array 객체 저장하고
    // 지역변수 setNames 에는 지역변수 names 안을 갱신하는 익명함수 저장하기
    // 이후부터 setNames(~)가 호출되면 함수컴포넌트 안의 코딩이 재 실행된다.
    // 재 실행 시 useState 함수 호출이 있는 코딩줄은 재 실행에서 제외된다.
    // 이제부터 names 는 마치 클래스 컴포넌트의 state 속성변수와 동일한 성격을 가지게 된다.
    // ----------------------------------------------------------------
    const [names, setNames] = useState (
            [
            {id:1,text:'사오정'}
            ,{id:2,text:'저팔계'}
            ,{id:3,text:'손오공'}
            ,{id:4,text:'삼장법사'}
            ]
    );
    // ----------------------------------------------------------------
    // 지역변수 inputText, setInputText 선언하고
    // 지역변수 inputText 에는 '' 저장하고
    // 지역변수 setInputText 에는 지역변수 inputText 안을 갱신하는 익명함수 저장하기
    // 이후부터 setInputText(~) 이 호출되면 함수 컴포넌트 안의 코딩이 재실행된다.
    // 재 실행 시 useState 함수 호출이 있는 코딩줄은 재 실행에서 제외된다.
    // 이제부터 inputText는 마치 클래스 컴포넌트의 state 속성변수와 동일한 성격을 가지게된다.
    // ----------------------------------------------------------------
    const [inputText, setInputText] = useState('');

    // ----------------------------------------------------------------
    // 지역변수 nextId, setNextID 선언하고
    // 지역변수 nextId 에는 names.length_+1 결과 저장하고
    // 지역변수 setNextId 에는 지역변수 nextId 안을 갱신하는 익명함수 저장하기
    // 이후 부터 setNextId(~) 가 호출되면 함수컴포넌트 안의 코딩이 재 실행된다.
    // 재 실행 시 useState 함수 호출이 있는 코딩줄은 재실행에서 제외된다.
    // 이제부터 nextId 는 마치 클래스 컴포넌트의 state 속성변수와 동일한 성격을 가지게된다.
    // ----------------------------------------------------------------
    const [nextId, setNextID] = useState(names.length+1);
    
    // ----------------------------------------------------------------
    // 화살표 함수가 저장된 지역변수 선언.
    // 아래 매개변수 e 에는 Event 객체가 들어온다.
    // 즉 아래 화살표함수는 입력양식에 이벤트가 발생했을 때 실행할 구문을 내포하고 있다.
    // ----------------------------------------------------------------
    const textChange = (e) => {
        
        // 지역변수 inputText에 이벤트가 발생한 놈의 value 값을 저장하기
        let val = e.target.value;

        // 앞뒤 공백 제거하고 재 저장하기
        val = val.trim();

        /*
        while (val.indexOf(" ")==0) {
            val = val.substring(1)
        }

        while (val.lastIndexOf(" ")==val.length-1) {
            val = val.substring(val.length-2)
        }
        */

        // 지역변수 val 안의 지역변수 inputText에 저장하기
        // <참고> value 속성을 가진 놈은 입력양식 태그 밖에 없다.
        setInputText(val);


    }
    // ----------------------------------------------------------------
    // 화살표 함수가 저장된 지역변수 add 선언.
    // 화살표함수 안에는 추가 버튼 클릭시 호출되는 실행 구문을 내포하고 있다.
    // ----------------------------------------------------------------
    const add = () => {
        // ----------------------------------------------------------------
        // 만약 입력한 데이터가 비어있으면 경고하고 함수 중단.
        // ----------------------------------------------------------------
        if(inputText==null || inputText==undefined || inputText.split(" ").join("")=="") {
            alert ("데이터가 비어있어 입력 불가능");
            setInputText("");
            // ----------------------------------------------------------------
            // ref={nameRef} 가진 태그에 포커스 들여놓기.
            // ----------------------------------------------------------------
            nameRef.current.focus();
            return;
        }
        // ----------------------------------------------------------------
        // 만약 중복되어 있으면 경고하고 함수 중단
        // ----------------------------------------------------------------
        if (names!=null) {
            /*
            for (let i=0; i<names.length; i++) {
                if ( names[i].text==inputText ) {
                    alert (inputText+"문자 이미 있어서 입력 불가능");
                    setInputText("");
                    return;
                }
            }
        */
            const tmpNames = names.filter(name=>name.text===inputText);
            if (tmpNames.length>0) {
                alert (inputText+"문자 이미 있어서 입력 불가능");
                setInputText("");
                nameRef.current.focus();
                return;
            }
        }
        // ----------------------------------------------------------------
        // 지역변수 newNames 선언하고
        // names 안의 Array 객체 복사하고 {id: nextId, text: inputText} 추가하고
        // 이렇게 만들어 새로운 Array 객체를 newNames에 저장하기
        // ----------------------------------------------------------------
        const newNames = names.concat({
            id: nextId,         // nextId 값을 id로 설정하고
            text: inputText
        });
        // ----------------------------------------------------------------
        // newNames 안의 Array 객체를 기존 names 안에 갱신해서 저장하기
        // ----------------------------------------------------------------
        setNames(newNames);
        // ----------------------------------------------------------------
        // nextId 지역변수에 nextId+1 의 실행결과 저장하기.
        // 즉 기본 데이터에서 1 증가하란 의미
        // ----------------------------------------------------------------
        setNextID(nextId+1);
        // ----------------------------------------------------------------
        // inputText 지역변수에 "" 저장하기
        // 즉 결국 입력 양식이 비어지게 된다.
        // ----------------------------------------------------------------
        setInputText("");

        // ----------------------------------------------------------------
        // ref={nameRef} 가진 태그에 포커스 들여놓기.
        // ----------------------------------------------------------------
        nameRef.current.focus();
    }
    // ----------------------------------------------------------------
    // 화살표 함수가 저장된 지역변수 remove 선언
    // 화살표 함수 안에는 목록을 더블클릭하면 목록을 삭제하는 구문이 내포되어있다.
    // 매개변수 더블클릭하는 목록의 고유값인 id 값이 들어 온다.
    // ----------------------------------------------------------------
    const remove = (id) => {
        // ----------------------------------------------------------------
        // 지역변수 nextNames 선언하고
        // Array 객체의 filter 메소드를 호출하여
        // names에 저장된 사용자정의 객체를 1개씩 꺼내서
        // 아래의 화살표 함수를 호출하여 리턴되는 데이터가 true 일때만
        // 사용자정의 객체만 복사해 누적하기
        // 즉 매개변수로 들어온 id와 같지않은 놈만 골라서 누적하기
        // ----------------------------------------------------------------
        const nextNames = names.filter(name=>name.text.id !==id);
        // ----------------------------------------------------------------
        // names 지역변수에 nextNames 안의 Array 객체로 갱신하기
        // 즉 기존 데이터에서  1 증가하란 의미
        // ----------------------------------------------------------------
        setNames(nextNames);
    };
    // ----------------------------------------------------------------
    // 지역변수 namesTag 선언하고
    // Array 객체의 map 메소드를 호출하여
    // names 에 저장된 사용자정의 객체를 1개씩 꺼내서
    // 아래의 화살표 함수를 호출하여 리턴되는 html 코딩을 누적해 저장하기
    // ----------------------------------------------------------------
    const namesTag = names.map(
        name =>
            <li style={{cursor:'pointer'}} key={name.id}>
                {name.text}
            </li>
    );
    // ----------------------------------------------------------------
    // JSX 문법을 가진 return 구문 선언
    // 리턴되는 JSX 문법이 결국 웹화면에 출력된다.
    // ----------------------------------------------------------------    
    return(

        <>
            <center>
                {inputText}
                <table><tr><td>
                <input type='text' ref={nameRef} value={inputText} onChange={textChange}/>&nbsp;
                <button onClick={add}>추가</button>
                <ul>{namesTag}</ul>
                </td></tr></table>
            </center>
        </>
    )

}

export default RegData;